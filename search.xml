<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Bilibili视频</title>
      <link href="/2023/01/05/Bilibili%E8%A7%86%E9%A2%91/"/>
      <url>/2023/01/05/Bilibili%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>测试bilibili视频</p><span id="more"></span><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://www.bilibili.com/video/BV1ZG4y127ks/?share_source=copy_web&vd_source=a575d24748d9d944eda0ed7e2d17a5b5" scrolling="no" border="0"     frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%;     height: 100%; left: 0; top: 0;">     </iframe></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity gitignore</title>
      <link href="/2023/01/05/Unity/Unity%E7%9A%84gitignore/"/>
      <url>/2023/01/05/Unity/Unity%E7%9A%84gitignore/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity的gitignore"><a href="#Unity的gitignore" class="headerlink" title="Unity的gitignore"></a>Unity的gitignore</h1><span id="more"></span><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure><p>建立一个gitignore文件</p><p>然后粘贴</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"># This .gitignore file should be placed at the root of your Unity project directory</span><br><span class="line">#</span><br><span class="line"># Get latest from https://github.com/github/gitignore/blob/main/Unity.gitignore</span><br><span class="line">#</span><br><span class="line">/[Ll]ibrary/</span><br><span class="line">/[Tt]emp/</span><br><span class="line">/[Oo]bj/</span><br><span class="line">/[Bb]uild/</span><br><span class="line">/[Bb]uilds/</span><br><span class="line">/[Ll]ogs/</span><br><span class="line">/[Uu]ser[Ss]ettings/</span><br><span class="line"></span><br><span class="line"># MemoryCaptures can get excessive in size.</span><br><span class="line"># They also could contain extremely sensitive data</span><br><span class="line">/[Mm]emoryCaptures/</span><br><span class="line"></span><br><span class="line"># Recordings can get excessive in size</span><br><span class="line">/[Rr]ecordings/</span><br><span class="line"></span><br><span class="line"># Uncomment this line if you wish to ignore the asset store tools plugin</span><br><span class="line"># /[Aa]ssets/AssetStoreTools*</span><br><span class="line"></span><br><span class="line"># Autogenerated Jetbrains Rider plugin</span><br><span class="line">/[Aa]ssets/Plugins/Editor/JetBrains*</span><br><span class="line"></span><br><span class="line"># Visual Studio cache directory</span><br><span class="line">.vs/</span><br><span class="line"></span><br><span class="line"># Gradle cache directory</span><br><span class="line">.gradle/</span><br><span class="line"></span><br><span class="line"># Autogenerated VS/MD/Consulo solution and project files</span><br><span class="line">ExportedObj/</span><br><span class="line">.consulo/</span><br><span class="line">*.csproj</span><br><span class="line">*.unityproj</span><br><span class="line">*.sln</span><br><span class="line">*.suo</span><br><span class="line">*.tmp</span><br><span class="line">*.user</span><br><span class="line">*.userprefs</span><br><span class="line">*.pidb</span><br><span class="line">*.booproj</span><br><span class="line">*.svd</span><br><span class="line">*.pdb</span><br><span class="line">*.mdb</span><br><span class="line">*.opendb</span><br><span class="line">*.VC.db</span><br><span class="line"></span><br><span class="line"># Unity3D generated meta files</span><br><span class="line">*.pidb.meta</span><br><span class="line">*.pdb.meta</span><br><span class="line">*.mdb.meta</span><br><span class="line"></span><br><span class="line"># Unity3D generated file on crash reports</span><br><span class="line">sysinfo.txt</span><br><span class="line"></span><br><span class="line"># Builds</span><br><span class="line">*.apk</span><br><span class="line">*.aab</span><br><span class="line">*.unitypackage</span><br><span class="line">*.app</span><br><span class="line"></span><br><span class="line"># Crashlytics generated file</span><br><span class="line">crashlytics-build.properties</span><br><span class="line"></span><br><span class="line"># Packed Addressables</span><br><span class="line">/[Aa]ssets/[Aa]ddressable[Aa]ssets[Dd]ata/*/*.bin*</span><br><span class="line"></span><br><span class="line"># Temporary auto-generated Android Assets</span><br><span class="line">/[Aa]ssets/[Ss]treamingAssets/aa.meta</span><br><span class="line">/[Aa]ssets/[Ss]treamingAssets/aa/*</span><br></pre></td></tr></table></figure><p>网址：<a href="https://github.com/github/gitignore/blob/master/Unity.gitignore">https://github.com/github/gitignore/blob/master/Unity.gitignore</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader基础概念</title>
      <link href="/2023/01/05/Unity/Unity%20Shader/"/>
      <url>/2023/01/05/Unity/Unity%20Shader/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-Shader"><a href="#Unity-Shader" class="headerlink" title="Unity Shader"></a>Unity Shader</h1><span id="more"></span><h2 id="1-顶点着色器"><a href="#1-顶点着色器" class="headerlink" title="1.顶点着色器"></a>1.顶点着色器</h2><h3 id="实现顶点的空间变换，顶点着色，输出后续阶段所需的数据。输入来自CPU，输入进来的每个顶点都会调用顶点着色器。"><a href="#实现顶点的空间变换，顶点着色，输出后续阶段所需的数据。输入来自CPU，输入进来的每个顶点都会调用顶点着色器。" class="headerlink" title="实现顶点的空间变换，顶点着色，输出后续阶段所需的数据。输入来自CPU，输入进来的每个顶点都会调用顶点着色器。"></a>实现顶点的空间变换，顶点着色，输出后续阶段所需的数据。输入来自CPU，输入进来的每个顶点都会调用顶点着色器。</h3><p>坐标变换就是改变顶点的位置，把顶点坐标从模型空间转换到齐次裁剪空间。</p><h3 id="2-裁剪"><a href="#2-裁剪" class="headerlink" title="2.裁剪"></a>2.裁剪</h3><p>裁剪掉不在视野内的图元。</p><h3 id="3-屏幕映射"><a href="#3-屏幕映射" class="headerlink" title="3.屏幕映射"></a>3.屏幕映射</h3><p>把每个图元的x，y坐标转换到屏幕坐标系下。</p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>1.计算每个图元覆盖了拿些像素，2.计算这些像素的颜色</p><p>1.三角形设置</p><p>计算光栅化一个三角形网格所需的信息</p><p>2.三角形遍历（扫描变换）</p><p>根据几何阶段输出的顶点信息，得到该三角形网格覆盖的像素位置（如果被覆盖，就生成一个片元）。</p><p>一个片元并不是一个像素，而是很多状态的集合：屏幕坐标，深度信息，顶点信息，纹理坐标，法线。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Magica Cloth插件使用方法</title>
      <link href="/2023/01/05/Unity/Magica%20Cloth/"/>
      <url>/2023/01/05/Unity/Magica%20Cloth/</url>
      
        <content type="html"><![CDATA[<h1 id="Magica-Cloth"><a href="#Magica-Cloth" class="headerlink" title="Magica Cloth"></a>Magica Cloth</h1><span id="more"></span><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p><a href="https://pan.baidu.com/wap/init?surl=R-1Ff6eGouNNAAsA4aywuA&amp;pwd=gxun">https://pan.baidu.com/wap/init?surl=R-1Ff6eGouNNAAsA4aywuA&amp;pwd=gxun</a></p><p>百度网盘快速下载我发过视频：</p><p><a href="https://www.bilibili.com/video/BV1JY4y1C74g?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1JY4y1C74g?spm_id_from=333.999.0.0</a></p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>先导入两个包：Brust和Jobs</p><p>导入Jobs要从add from git URL，输入com.unity.jobs，等待一会儿就可以了。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>导入fbx模型，找一下衣服和头发的节点：</p><p><img src="https://i0.hdslb.com/bfs/album/42d352f6f48612b594fac8b7a4f883e9d3ffac5e.png" alt="image-20220713170431760"></p><p>简单给个参考：</p><p><img src="https://i0.hdslb.com/bfs/album/d1c20b928d9688296f1a5902b62e4e0221519bcc.png" alt="image-20220714120843463"></p><p>给头发添加组件：MagicaBoneCloth</p><p><img src="https://i0.hdslb.com/bfs/album/49e8f950b8303493d4e29bb807741ff4ae4d75d3.png" alt="image-20220713170537847"></p><p>把头发的两个根节点添加进去：</p><p><img src="https://i0.hdslb.com/bfs/album/f954b5feb97a3d733723a5f8b870e92c1911f88d.png" alt="image-20220713170634619"></p><p>点一下开始选择点位，可以看到头发上的点：</p><p><img src="https://i0.hdslb.com/bfs/album/74e5e250d6292d85825c3fb07e75fcb1530d95ec.png" alt="image-20220713171206484"></p><p>load一下布料的种类：</p><p><img src="https://i0.hdslb.com/bfs/album/8c499b05d79d0736ff59e764d903838f7fd395fc.png" alt="image-20220713171248689"></p><p>点create创建。</p><p>如果穿模的话，可以建collider：</p><p><img src="https://i0.hdslb.com/bfs/album/863dbaf5f26393f80acdc4897874434780977139.png" alt="image-20220713173840407"></p><p>添加碰撞后，记得拖进来：</p><p><img src="https://i0.hdslb.com/bfs/album/f4c69c4088341e63a8db3af535966494f1c1ed67.png" alt="image-20220713174234219"></p><p>在chest也加点摇摆：</p><p><img src="https://i0.hdslb.com/bfs/album/31f629127fdf69811aa22370c9f42a8f362fc401.png" alt="image-20220713174424239"></p><p>两个节点拖进去，选bonespring 的预设。</p><p><img src="https://i0.hdslb.com/bfs/album/7c065a270d195c5c83a035e19d44de96dddf583d.png" alt="image-20220713174526104"></p><p>可以调强度，越小晃得越厉害。</p><p><img src="https://i0.hdslb.com/bfs/album/12289ea2b3045309d0c9f10432cb9c4d1815360b.png" alt="image-20220713174646419"></p><p>可以加个风看看布料的效果：</p><p><img src="https://i0.hdslb.com/bfs/album/891ba8bd700f190326752b99f84eaa5e493c6ad4.png" alt="image-20220713174835895"></p><p>效果：</p><p><img src="https://i0.hdslb.com/bfs/album/4207c64a67624efed09b0554b119b2fcd5024b5a.png" alt="image-20220713180026533"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MMD表情制作技巧</title>
      <link href="/2023/01/05/Unity/MMD%E8%A1%A8%E6%83%85/"/>
      <url>/2023/01/05/Unity/MMD%E8%A1%A8%E6%83%85/</url>
      
        <content type="html"><![CDATA[<h1 id="镜头与表情"><a href="#镜头与表情" class="headerlink" title="镜头与表情"></a>镜头与表情</h1><span id="more"></span><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><a href="https://github.com/ShiinaManatsu/MMD4UnityTools/releases/tag/1.1.0.3">https://github.com/ShiinaManatsu/MMD4UnityTools/releases/tag/1.1.0.3</a></p><p>改一下这几行代码：</p><p><img src="https://i0.hdslb.com/bfs/album/574a1070b9833e9f4adc41b90f9b1a40feb13435.png" alt="image-20220713194636016"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var curve = new AnimationCurve(package.ToArray());</span><br><span class="line"></span><br><span class="line">varchara = GameObject.Find(&quot;U_Char_2&quot;);</span><br><span class="line">var gameObjectName = chara.name;</span><br><span class="line">var parentName = chara.transform.parent.name;</span><br><span class="line">var mesh = chara.GetComponent&lt;SkinnedMeshRenderer&gt;().sharedMesh;</span><br></pre></td></tr></table></figure><p>剩下的就简单了，找到vmd文件：</p><p><img src="https://i0.hdslb.com/bfs/album/2417d548f90de6a2aef7819605d3ddb28ab306b2.png" alt="image-20220713195310304"></p><p>会创建出来表情动画。</p><p>在动画控制器新建layer来播放表情动画。</p><p><img src="https://i0.hdslb.com/bfs/album/3bafb408d2d937aa8383cd2a5765b0a907aaebb6.png" alt="image-20220713195334329"></p><p>新建一个avatar：</p><p><img src="https://i0.hdslb.com/bfs/album/467706a73a2831e9b9bc3b2990a9acb9aba230ce.png" alt="image-20220713195525802"></p><p>仅保留手部是绿色。</p><p><img src="https://i0.hdslb.com/bfs/album/326d1ffc3f24cd07659ce4ea88bd5a3f76517244.png" alt="image-20220713195606432"></p><p>把刚刚设置的face遮罩avatar设置为这个。</p><p><img src="https://i0.hdslb.com/bfs/album/0af026b565cbe85439ad1f23260c49328b457208.png" alt="image-20220713195703656"></p><p>权重也设置为1.</p><p>点播放，就可以看到表情变化啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 网格类开源项目</title>
      <link href="/2023/01/05/Unity/Unity%20%E7%BD%91%E6%A0%BC%E7%B1%BB%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/01/05/Unity/Unity%20%E7%BD%91%E6%A0%BC%E7%B1%BB%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-网格类开源项目"><a href="#Unity-网格类开源项目" class="headerlink" title="Unity 网格类开源项目"></a>Unity 网格类开源项目</h1><span id="more"></span><p>地址：<a href="https://blog.csdn.net/linxinfa/article/details/118669910?spm=1001.2014.3001.5501">https://blog.csdn.net/linxinfa/article/details/118669910?spm=1001.2014.3001.5501</a></p><h4 id="1、2D网格涂鸦"><a href="#1、2D网格涂鸦" class="headerlink" title="1、2D网格涂鸦"></a>1、2D网格涂鸦</h4><p>项目地址：<a href="https://github.com/mattatz/unity-triangulation2D">https://github.com/mattatz/unity-triangulation2D</a></p><p><img src="https://i0.hdslb.com/bfs/album/b241a7f3e8827f7f7a7121d27aef00553e2fb9a7.png" alt="image-20220624183334878"></p><h4 id="2、3D网格涂鸦"><a href="#2、3D网格涂鸦" class="headerlink" title="2、3D网格涂鸦"></a>2、3D网格涂鸦</h4><p>项目地址：<a href="https://github.com/mattatz/unity-teddy">https://github.com/mattatz/unity-teddy</a></p><p><img src="https://i0.hdslb.com/bfs/album/edcc7ae02b48aceb65a2481e21081c67f8e285c1.png" alt="image-20220624183346195"></p><h4 id="3、网格体素化"><a href="#3、网格体素化" class="headerlink" title="3、网格体素化"></a>3、网格体素化</h4><p>项目地址：<a href="https://github.com/Scrawk/Mesh-Voxelization">https://github.com/Scrawk/Mesh-Voxelization</a></p><p><img src="https://i0.hdslb.com/bfs/album/3ea5f92e62ffecad7375e91ca2067a0d4e80ade0.png" alt="image-20220624183355338"></p><h4 id="4、网格平滑算法"><a href="#4、网格平滑算法" class="headerlink" title="4、网格平滑算法"></a>4、网格平滑算法</h4><p>项目地址：<a href="https://github.com/mattatz/unity-mesh-smoothing">https://github.com/mattatz/unity-mesh-smoothing</a></p><p><img src="https://i0.hdslb.com/bfs/album/5d7a7e20b10132ea3441e88fe92d5c8977b2ce2c.png" alt="image-20220624183404297"></p><h4 id="5、网格切割"><a href="#5、网格切割" class="headerlink" title="5、网格切割"></a>5、网格切割</h4><p>项目地址：<a href="https://github.com/hugoscurti/mesh-cutter">https://github.com/hugoscurti/mesh-cutter</a></p><p><img src="https://i0.hdslb.com/bfs/album/74c0690fe0778e7b1869451b0b8cf561938d51b4.png" alt="image-20220624183414452"></p><h4 id="6、网格合并"><a href="#6、网格合并" class="headerlink" title="6、网格合并"></a>6、网格合并</h4><p>项目地址：<a href="https://github.com/sanukin39/UniMeshCombiner">https://github.com/sanukin39/UniMeshCombiner</a></p><p><img src="https://i0.hdslb.com/bfs/album/7d20438f545d9c58096d9febff65ee1084f9b130.png" alt="image-20220624183424589"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity MMD指南</title>
      <link href="/2023/01/05/Unity/Unity%20MMD%E6%8C%87%E5%8D%97/"/>
      <url>/2023/01/05/Unity/Unity%20MMD%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-MMD指南"><a href="#Unity-MMD指南" class="headerlink" title="Unity MMD指南"></a>Unity MMD指南</h1><span id="more"></span><p>项目地址：<a href="https://github.com/IceMiaoMiao/Unity-MMD">https://github.com/IceMiaoMiao/Unity-MMD</a></p><h2 id="模型获取："><a href="#模型获取：" class="headerlink" title="模型获取："></a>模型获取：</h2><p>首先是国内大名鼎鼎的模之屋：<a href="https://www.aplaybox.com/%E3%80%81">https://www.aplaybox.com/、</a></p><p>然后是日本选手bowroll：<a href="https://bowlroll.net/">https://bowlroll.net/</a></p><p>可以从里面下载模型和vmd动作文件。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>来这个网站找pmx导入unity的插件：<a href="http://stereoarts.jp/">http://stereoarts.jp/</a></p><p><img src="https://i0.hdslb.com/bfs/album/aca3e63ffa8eff1350ac8420551b89500fc08230.png" alt="image-20220711212547390"></p><p>插件在这里，下载这个就行。</p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>先导入插件，然后把下载的pmx模型导入进unity。</p><p>然后可以建个文件夹，导入模型。</p><p><img src="https://i0.hdslb.com/bfs/album/57b1cb95a1096f032dde9e426edd04f3ba895623.png" alt="image-20220712173037235"></p><p>往unity导入模型的时候，只需要导入这两个：tex文件夹和pmx文件。</p><p>如果刚才插件导入成功，当你导入pmx文件的时候，会发现自动生成了一个文件。</p><p><img src="https://i0.hdslb.com/bfs/album/f67d389164ae115d0565d5cb3e818cdd6b0ada34.png" alt="image-20220711231614746"></p><p>同意一下条款，然后选好pmx文件和vmd文件。点process。</p><p><img src="https://i0.hdslb.com/bfs/album/b050706f87286e3dfcfa9f44475112871730652e.png" alt="image-20220711215752266"></p><p>如果需要多个动画文件，这里就多导入几个vmd。一个萝卜一个坑，不能给其他动画了。</p><p>它就会给我们生成动画文件和模型的fbx。</p><p><img src="https://i0.hdslb.com/bfs/album/87e486831c3dad93aac59ed161db63e202e48e04.png" alt="image-20220712164140267"></p><p>报错的话，就点clear，清理一下bug（bushi（虽然无关紧要就是说）</p><p><img src="https://i0.hdslb.com/bfs/album/6b8b997ad2ee450595d9bc2be6682f1d2ba15c18.png" alt="image-20220711215831910"></p><p>rig设置为humanoid，然后再进行下一步，点rig旁边的animation，这个顺序不能错。</p><p><img src="https://i0.hdslb.com/bfs/album/7bdd47ceef79f09c5a4a70b8fbf4fbd81e1746bd.png" alt="image-20220711215911521"></p><p>动画也可以随便设置一下。</p><p><img src="https://i0.hdslb.com/bfs/album/a5b8ae7263f90a1908380824a7780a6394beddac.png" alt="image-20220711215945180"></p><p>顺便加个平滑的曲线。</p><p>点安apply应用。</p><p><img src="https://i0.hdslb.com/bfs/album/823ad31dbbb2c0f029f4fad2967f6b2c723958d6.png" alt="image-20220712165156250"></p><p>可以右下角播放看看效果。</p><p><img src="https://i0.hdslb.com/bfs/album/6babdb530fe95b0dced286c1a762a487d36cbda7.png" alt="image-20220711220118791"></p><p>为了方便管理，也是为了修改动画文件。我们把动画文件ctrl+D。复制出来一个，可以单独放一个文件夹，无所谓了。</p><p>然后把动画文件拖到角色上，会生成一个Animation Control。可以预览一下动画是否正常播放。</p><p>材质的话，老办法</p><p><img src="https://i0.hdslb.com/bfs/album/cc530cf7b7b33bdeea62752439eabd9e809081c9.png" alt="image-20220711232123412"></p><p>对fbx文件这样设置，把材质导出来。</p><p>不要管它生成的材质了，数量太多，有点杂，麻烦。</p><p>直接在tex文件夹里面，根据tex数量建对应数量的material。</p><p><img src="https://i0.hdslb.com/bfs/album/98a4a81c2ed378d65789e956734c47fdc81b3911.png" alt="image-20220712170540471"></p><p>然后右边简单调一下效果。</p><p>我简单给一个Shader：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Toon/Basic/MultiSteps&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        // Colors</span><br><span class="line">        _Color (&quot;Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _HColor (&quot;Highlight Color&quot;, Color) = (0.8, 0.8, 0.8, 1.0)</span><br><span class="line">        _SColor (&quot;Shadow Color&quot;, Color) = (0.2, 0.2, 0.2, 1.0)</span><br><span class="line">        </span><br><span class="line">        // texture</span><br><span class="line">        _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123; &#125;</span><br><span class="line">        </span><br><span class="line">        // ramp</span><br><span class="line">        _ToonSteps (&quot;Steps of Toon&quot;, range(1, 9)) = 2</span><br><span class="line">        _RampThreshold (&quot;Ramp Threshold&quot;, Range(0.1, 1)) = 0.5</span><br><span class="line">        _RampSmooth (&quot;Ramp Smooth&quot;, Range(0, 1)) = 0.1</span><br><span class="line">        </span><br><span class="line">        // specular</span><br><span class="line">        _SpecColor (&quot;Specular Color&quot;, Color) = (0.5, 0.5, 0.5, 1)</span><br><span class="line">        _SpecSmooth (&quot;Specular Smooth&quot;, Range(0, 1)) = 0.1</span><br><span class="line">        _Shininess (&quot;Shininess&quot;, Range(0.001, 10)) = 0.2</span><br><span class="line">        </span><br><span class="line">        // rim light</span><br><span class="line">        _RimColor (&quot;Rim Color&quot;, Color) = (0.8, 0.8, 0.8, 0.6)</span><br><span class="line">        _RimThreshold (&quot;Rim Threshold&quot;, Range(0, 1)) = 0.5</span><br><span class="line">        _RimSmooth (&quot;Rim Smooth&quot;, Range(0, 1)) = 0.1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        CGPROGRAM</span><br><span class="line">        </span><br><span class="line">        #pragma surface surf Toon addshadow fullforwardshadows exclude_path:deferred exclude_path:prepass</span><br><span class="line">        #pragma target 3.0</span><br><span class="line">        </span><br><span class="line">        fixed4 _Color;</span><br><span class="line">        fixed4 _HColor;</span><br><span class="line">        fixed4 _SColor;</span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        </span><br><span class="line">        float _RampThreshold;</span><br><span class="line">        float _RampSmooth;</span><br><span class="line">        float _ToonSteps;</span><br><span class="line">        </span><br><span class="line">        float _SpecSmooth;</span><br><span class="line">        fixed _Shininess;</span><br><span class="line">        </span><br><span class="line">        fixed4 _RimColor;</span><br><span class="line">        fixed _RimThreshold;</span><br><span class="line">        float _RimSmooth;</span><br><span class="line">        </span><br><span class="line">        struct Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            float3 viewDir;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        float linearstep(float min, float max, float t)</span><br><span class="line">        &#123;</span><br><span class="line">            return saturate((t - min) / (max - min));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        inline fixed4 LightingToon(SurfaceOutput s, half3 lightDir, half3 viewDir, half atten)</span><br><span class="line">        &#123;</span><br><span class="line">            half3 normalDir = normalize(s.Normal);</span><br><span class="line">            half3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line">            </span><br><span class="line">            float ndl = max(0, dot(normalDir, lightDir));</span><br><span class="line">            float ndh = max(0, dot(normalDir, halfDir));</span><br><span class="line">            float ndv = max(0, dot(normalDir, viewDir));</span><br><span class="line">            </span><br><span class="line">            // multi steps</span><br><span class="line">            float diff = smoothstep(_RampThreshold - ndl, _RampThreshold + ndl, ndl);</span><br><span class="line">            float interval = 1 / _ToonSteps;</span><br><span class="line">            // float ramp = floor(diff * _ToonSteps) / _ToonSteps;</span><br><span class="line">            float level = round(diff * _ToonSteps) / _ToonSteps;</span><br><span class="line">            float ramp ;</span><br><span class="line">            if (_RampSmooth == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                ramp = interval * linearstep(level - _RampSmooth * interval * 0.5, level + _RampSmooth * interval * 0.5, diff) + level - interval;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ramp = interval * smoothstep(level - _RampSmooth * interval * 0.5, level + _RampSmooth * interval * 0.5, diff) + level - interval;</span><br><span class="line">            &#125;</span><br><span class="line">            ramp = max(0, ramp);</span><br><span class="line">            ramp *= atten;</span><br><span class="line">            </span><br><span class="line">            _SColor = lerp(_HColor, _SColor, _SColor.a);</span><br><span class="line">            float3 rampColor = lerp(_SColor.rgb, _HColor.rgb, ramp);</span><br><span class="line">            </span><br><span class="line">            // specular</span><br><span class="line">            float spec = pow(ndh, s.Specular * 128.0) * s.Gloss;</span><br><span class="line">            spec *= atten;</span><br><span class="line">            spec = smoothstep(0.5 - _SpecSmooth * 0.5, 0.5 + _SpecSmooth * 0.5, spec);</span><br><span class="line">            </span><br><span class="line">            // rim</span><br><span class="line">            float rim = (1.0 - ndv) * ndl;</span><br><span class="line">            rim *= atten;</span><br><span class="line">            rim = smoothstep(_RimThreshold - _RimSmooth * 0.5, _RimThreshold + _RimSmooth * 0.5, rim);</span><br><span class="line">            </span><br><span class="line">            fixed3 lightColor = _LightColor0.rgb;</span><br><span class="line">            </span><br><span class="line">            fixed4 color;</span><br><span class="line">            fixed3 diffuse = s.Albedo * lightColor * rampColor;</span><br><span class="line">            fixed3 specular = _SpecColor.rgb * lightColor * spec;</span><br><span class="line">            fixed3 rimColor = _RimColor.rgb * lightColor * _RimColor.a * rim;</span><br><span class="line">            </span><br><span class="line">            color.rgb = diffuse + specular + rimColor;</span><br><span class="line">            color.a = s.Alpha;</span><br><span class="line">            return color;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        void surf(Input IN, inout SurfaceOutput o)</span><br><span class="line">        &#123;</span><br><span class="line">            fixed4 mainTex = tex2D(_MainTex, IN.uv_MainTex);</span><br><span class="line">            o.Albedo = mainTex.rgb * _Color.rgb;</span><br><span class="line">            </span><br><span class="line">            o.Alpha = mainTex.a * _Color.a;</span><br><span class="line">            </span><br><span class="line">            o.Specular = _Shininess;</span><br><span class="line">            o.Gloss = mainTex.a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者用这个卡通渲染的Shader：<a href="https://github.com/Sorumi/UnityToonShader">https://github.com/Sorumi/UnityToonShader</a></p><p>然后把材质拖到模型上的对应位置。仔细一点，不要漏了。</p><p>效果图：</p><p><img src="https://i0.hdslb.com/bfs/album/51b067314ba968cb135f24d057e844ec0b227360.png" alt="image-20220711233219802"></p><p>看起来还不错。</p><p>点击相机，ctrl+shift+F，把摄像机变换到我们当前的视角。</p><p>点运行，模型动起来啦！</p><h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>把模型和场景保存为预制体，然后用AssetBundle导出一下，做AR。</p><p><img src="https://i0.hdslb.com/bfs/album/3b928fd4584d7ae03ac48cdf7fdaeeb7e05cc070.png" alt="image-20220712172025178"></p><p>华为河图需要build ios和安卓。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>单独建一个工程，导入toolya插件，登录。</p><p><img src="https://i0.hdslb.com/bfs/album/58abeaafca95493a88303b8bdf30a8acdbd52648.png" alt="image-20220712172244276"></p><p>依次点资源模板，我的导入，上传。</p><p>把刚刚的ab包上传一下就ok啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub-For-Unity</title>
      <link href="/2023/01/05/Unity/GitHub-For-Unity/"/>
      <url>/2023/01/05/Unity/GitHub-For-Unity/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-For-Unity"><a href="#GitHub-For-Unity" class="headerlink" title="GitHub-For-Unity"></a>GitHub-For-Unity</h1><span id="more"></span><p>网上找到了一个针对Unity的GitHub工具，折腾了一上午，终于push成功了。感觉还是挺好用的，稍稍介绍一下。</p><p><img src="https://i0.hdslb.com/bfs/album/ff9afa7579e41f2b057326a3ef85eb62a9a5edac.png" alt="image-20220623135525170"></p><p>这是项目地址：<a href="https://github.com/github-for-unity/Unity">https://github.com/github-for-unity/Unity</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这个包有两种安装方式，一种是自己下载，手动导入工程中，另一种是通过Asset Store商店下载安装</p><h3 id="先说一下第一种"><a href="#先说一下第一种" class="headerlink" title="先说一下第一种"></a>先说一下第一种</h3><p>可以从官网或者GitHub下载最新版工程文件</p><p>官网：<a href="https://unity.github.com/">https://unity.github.com/</a></p><p><img src="https://i0.hdslb.com/bfs/album/056876856fb61517a4d3c298b4a9262041cf581c.png" alt="image-20220623140133615"></p><p>GitHub：</p><p><a href="https://github.com/github-for-unity/Unity/releases">https://github.com/github-for-unity/Unity/releases</a></p><p><img src="https://i0.hdslb.com/bfs/album/6252508e644cb10d13013805cc6325925f25088b.png" alt="image-20220623140340014"></p><p>可以下载最新版安装包，得到一个unitypackage文件，然后直接导入自己的工程就行。</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>去Asset Store直接搜github-for-unity</p><p><img src="https://i0.hdslb.com/bfs/album/40a710db08ba2906ebaa9496351d7cb733d4de82.png" alt="image-20220623140541076"></p><p>添加到我的资源</p><h2 id="导入与初始化"><a href="#导入与初始化" class="headerlink" title="导入与初始化"></a>导入与初始化</h2><p>将包导入unity工程后，可以在windows菜单中访问它</p><p><img src="https://i0.hdslb.com/bfs/album/e090aa93db68e9c50696f43f7dbb34feeb853ea1.png" alt="image-20220623140822794"></p><p>先进行初始化</p><p><img src="https://i0.hdslb.com/bfs/album/7cc737fb705d6091ecd8e2375b9f9fd4899761ad.png" alt="image-20220623141603157"></p><p>然后打开GitHub的菜单，右上角有sign in选项</p><p><img src="https://i0.hdslb.com/bfs/album/59105d3df2383595c5344cef9838f62ed4e5d2f7.png" alt="image-20220623140928284"></p><p>登录你自己的GitHub账号（这一步有问题的话可以关闭工程重新打开）</p><p>然后我们去GitHub网站建一个库，方便我们push</p><p><img src="https://i0.hdslb.com/bfs/album/2c2cba3ee225ea22c06be27346d218ab50c3d239.png" alt="image-20220623141146930"></p><p><img src="https://i0.hdslb.com/bfs/album/525ac7ec3923827e6fb57731ed822ecfa2a67eca.png" alt="image-20220623141201331"></p><p>给仓库起个名字，添加描述。</p><p>我们需要一个空仓库，所以这一步不添加readme文件，不添加.gitignore不选择license(就是说全部保持默认即可)</p><p><img src="https://i0.hdslb.com/bfs/album/dd44a0a0c95728a3749d362186263b170b62cf62.png" alt="image-20220623141413666"></p><p>复制一下这个代码</p><p><img src="https://i0.hdslb.com/bfs/album/23803ef876ab55b7fb2ad4119e1dd24b8fbc314f.png" alt="image-20220623141431741"></p><p>粘贴到这里，然后点save responsibility。这里就是我们一会要push的仓库地址</p><p><img src="https://i0.hdslb.com/bfs/album/9741ec9c2f30fff610321b02f8967c1cce4d3681.png" alt="image-20220623141624018"></p><p>提交changes，添加描述</p><p><img src="https://i0.hdslb.com/bfs/album/33e5bd0b203bd38e67a60d9826921c53cfc64e6e.png" alt="image-20220623141708888"></p><p>可以在历史记录看到更改</p><p><img src="https://i0.hdslb.com/bfs/album/245bf2419fc178d509be02ec3bddf03b8d583632.png" alt="image-20220623141738805"></p><p>然后我们就可以push了</p><p><img src="https://i0.hdslb.com/bfs/album/b2f7e830fc526ed1c50b9aafdf298738a3734559.png" alt="image-20220623141838004"></p><p>push成功啦，我们现在可以在刚刚创建的仓库里面看到更改了</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>遇到问题最多的是push的时候</p><h4 id="报错Failed-to-connect-to-github-com-port-443-Timed-out"><a href="#报错Failed-to-connect-to-github-com-port-443-Timed-out" class="headerlink" title="报错Failed to connect to github.com port 443: Timed out"></a>报错Failed to connect to github.com port 443: Timed out</h4><p>这个可能时网络或者代理的错误，我也试了很多办法。</p><h5 id="1-关闭项目代理"><a href="#1-关闭项目代理" class="headerlink" title="1.关闭项目代理"></a>1.关闭项目代理</h5><p>进入项目的本地仓库目录下，右键Git Bash Here进入控制台，分别执行以下两个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h5 id="2-修改hosts文件"><a href="#2-修改hosts文件" class="headerlink" title="2.修改hosts文件"></a>2.修改hosts文件</h5><p>进入C:\Windows\System32\drivers\etc目录下</p><p><img src="https://i0.hdslb.com/bfs/album/b9c7261b56d1bf6d7236fc479458e968f9a7dab7.png" alt="image-20220623142531542"></p><p>打开host文件，我这里选择记事本打开</p><p>查找一下GitHub网站的IP地址，填进去</p><p>用这个网站查：<a href="https://ipaddress.com/website/github.com">https://ipaddress.com/website/github.com</a></p><p><img src="https://i0.hdslb.com/bfs/album/3d48bd880ab90fd4ff9198bcc34e4bd19573c388.png" alt="image-20220623142814335"></p><p>复制一下ip地址，填到#::1             localhost下面一行</p><p><img src="https://i0.hdslb.com/bfs/album/111ecbffe0b33ccdec51d898e2d112a83e4f806f.png" alt="image-20220623142901083"></p><p>这是网上的办法，如果不能解决的话，可以换个加速器，或者重启试试</p><p><img src="https://i0.hdslb.com/bfs/album/257a10cea0c7ccbac270d5e3d7e28765c8c59932.png" alt="image-20220623143025239"></p><p>我这里用steam++解决了这个问题。</p><h4 id="git-SSL-certificate-problem-unable-to-get-local-issuer-certificate"><a href="#git-SSL-certificate-problem-unable-to-get-local-issuer-certificate" class="headerlink" title="git SSL certificate problem: unable to get local issuer certificate"></a>git SSL certificate problem: unable to get local issuer certificate</h4><p>这是由于当你通过HTTPS访问Git远程仓库的时候，如果服务器上的SSL证书未经过第三方机构认证，git就会报错。原因是因为未知的没有签署过的证书意味着可能存在很大的风险</p><p>进入当前仓库的目录，打开git bash here，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config http.sslverify false</span><br><span class="line">//这是对于当前仓库而言的 </span><br><span class="line">git config --global http.sslverify false</span><br><span class="line">//这个是针对当前系统用户</span><br><span class="line">git config --system http.sslverify false</span><br><span class="line">//这个是对于全局系统所有用户</span><br></pre></td></tr></table></figure><p>这些便是我在使用github-for-unity的时候遇到的一些问题，总的来说，这是一个很方便的工具，值得试试！</p><p>如果你在使用这个插件的过程中遇到了其他问题，可以与我联系</p><p>邮箱:<a href="mailto:&#103;&#x75;&#111;&#50;&#x33;&#49;&#56;&#56;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#x75;&#111;&#50;&#x33;&#49;&#56;&#56;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a></p><p>或者去bilibili私信我：<a href="https://space.bilibili.com/487294924?spm_id_from=333.1007.0.0">https://space.bilibili.com/487294924?spm_id_from=333.1007.0.0</a></p><p>感谢你能够看到这里，我们下次再见啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HiShader</title>
      <link href="/2023/01/05/Unity/HiShader/"/>
      <url>/2023/01/05/Unity/HiShader/</url>
      
        <content type="html"><![CDATA[<h1 id="HiShader"><a href="#HiShader" class="headerlink" title="HiShader"></a>HiShader</h1><span id="more"></span><h2 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h2><h3 id="1-MeshFilter-网格过滤器"><a href="#1-MeshFilter-网格过滤器" class="headerlink" title="1.MeshFilter(网格过滤器)"></a>1.MeshFilter(网格过滤器)</h3><p><img src="https://i0.hdslb.com/bfs/album/efbf8b3a002953b3da104a39dfb01e54629970a7.png" alt="img"></p><p>主要从众多的资源中挑选需要的<strong>Mesh</strong>，把它丢给<strong>MeshRender</strong></p><h3 id="MeshRender-网格渲染"><a href="#MeshRender-网格渲染" class="headerlink" title="MeshRender(网格渲染)"></a>MeshRender(网格渲染)</h3><p><img src="https://i0.hdslb.com/bfs/album/cb48f9e4349750b1bbba31cb5252128719d9e782.png" alt="img"></p><p>主要是负责把<strong>MeshFilter</strong>丢过来的<strong>Mesh</strong>，绘制显示到我们的场景中</p><h3 id="3-Material-材质"><a href="#3-Material-材质" class="headerlink" title="3.Material(材质)"></a>3.Material(材质)</h3><p><img src="https://i0.hdslb.com/bfs/album/70354f7c41e2294bf33619af163e05b30ba056ed.png" alt="img"></p><p><strong>Material</strong>是<strong>MeshRenderer</strong>中非常重要的角色，它的配置决定了物体表面的外观将以怎样的质地呈现到我们眼前。</p><p> <strong>Mesh 网格</strong> </p><p><img src="https://i0.hdslb.com/bfs/album/0f4963469ef5784aaa4050b8408c2636e0006047.png" alt="img"></p><p> <strong>Mesh</strong>指的就是模型的网格，它决定了物体的表面形状是怎样的，一个模型的表面大多是由多个彼此相连的三角面构成，当然也有其它类型。我们平时听到的建模，可以简单理解为就是在建网格，那为什么Unity中的网格大多都是三角形而不是四边形呢？正所谓一生二，二生三，三生万物。三角形可以说是最为基础的面了，可以简单理解为三角形具有更广泛的适用性，而Mesh则是构成这些三角面所需的信息集合。</p><p>通过 <a href="https://docs.unity.cn/cn/2021.3/Manual/AnatomyofaMesh.html">Mesh data - Unity 手册</a> 我们可以看到构成这些三角面所需的信息。</p><p><strong>Vertices</strong> <strong>顶点数组 Vector3[]</strong></p><p>顾名思义它存储的是顶点的相关信息，所谓点成线，线成面，可以理解为这里面存储的是构成网格面全部的点</p><p><strong>Topology 拓扑类型</strong></p><p>它存储的就是一个类型信息，可以理解为它是图形表面排列结构的组成方式，Unity给我们提供了5种拓扑类型，三角面、四边形、线条、虚线、点阵，最常用的则是三角面。</p><p><strong>Indices</strong> <strong>索引数组 int[]</strong></p><p>它是每个三角面顶点 的索引，可以理解为他存储了构网格三角面所用到的顶点索引。</p><p><strong>Vertex data</strong> <strong>顶点数据</strong></p><p><img src="https://i0.hdslb.com/bfs/album/f25b810dbb5d55362d66f94335da787c1413cba4.png" alt="img"></p><p>它包含了顶点的位置、法线、切线、UV等属性 </p><p> <strong>Normal 法线 Vector3[]</strong> </p><p>法线就是垂直于该顶点三角面的一条三维向量，它只有方向，没有大小。法线的方向就是顶点三角面朝外的方向。假设我们面前有一面镜子，它的正中心会有一条法线垂直于镜面指向我们，指向我们的面就是正面，相反就是背面</p><p> <strong>Tangent 切线 Vector3[]</strong> </p><p>它是垂直于法线的一条向量，而由于垂直于法线的向量有无数条，所以切线最终是由UV坐标来决定朝向的</p><p> <strong>UV  纹理坐标 Vector2[]</strong> </p><p>上面所说的UV坐标其实就是它，U增长的方向就是切线的方向，它和三维空间的X, Y, Z较为类似，它是一个二维的坐标系统，模型网格除了有三维空间的xyz坐标外，还有一个二维的UV坐标，在UV坐标中，U和V分别代表顶点在Texture水平和垂直方向上的采样坐标，这些坐标通常位于(0，0)和(1，1)之间，（0，0）代表最左下角，而（1，1）代表最右上角。这就跟平时装修房子贴墙纸一样，可以理解为它是Texture映射到模型表面的依据，模型顶点 会依据UV坐标对Texture进行采样。</p><p> <strong>Index data 索引数据</strong>  </p><p>这个数据取决于拓扑类型，如果是三角面他储存的就是[0,1,2]，四边形储存的就是[0,1,2,3]，这个索引数值对应的就是顶点数组的下标。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>定义立方体顶点数组</strong></p><p>正常来说立方体共有6个面，每个面由2个三角面组成，三角面有3个顶点数据，所以正常来说每个面需要有6个顶点数据，一共需要36个三角面顶点索引。那为什么这里我们每个面只用到了4个顶点数据呢，这是因为每个面的2个三角面顶点数据中有两个顶点它们的数据是共同的，Unity会直接通过索引找到相对应的数据。</p><p><img src="https://i0.hdslb.com/bfs/album/40c42ecff7d976eee3720643bbb35701d43faaa3.png" alt="img"></p><p>看到这里，可能又会有人觉得奇怪，既然共用的顶点数据可以通过索引找到，为什么一个立方面只有8个顶点，为什么这里不直接用8个顶点数据，而是需要24个？</p><p>这是因为Unity中不仅依靠这个三角面的索引数组索引三角面的顶点坐标，而且索引纹理坐标，索引法线向量。而立方体的每个顶点都参与了3个平面，而这个顶点相对于这3个平面来说，虽然顶点数据相同，但它们的法线向量是不同的，这个顶点在渲染这3个平面的时候则需要索引到不同的法线向量。而在Unity中由于顶点坐标和法线向量是由同一个索引值取得的，所以这里立方体一共8个顶点，每个顶点我们要存3份，刚好是24个顶点数据:</p><h2 id="2-渲染管线"><a href="#2-渲染管线" class="headerlink" title="2.渲染管线"></a>2.渲染管线</h2><h3 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h3><p>渲染管线通常来说就是在虚拟相机、三维物体、光源、照明模式、纹理等诸多条件都给定的情况下，生成 或是绘制一幅二维图像的过程。</p><p>一般这个过程会分为四个主要阶段：应用程序阶段、几何阶段、光栅化阶段、像素处理阶段。而每个阶段 又会分为很多个部分。</p><p><img src="https://i0.hdslb.com/bfs/album/11e3c758a75abe0ef6e0ee257592acb03600b23c.png" alt="img"></p><p><strong>应用程序阶段 （The Application Stage） CPU</strong></p><p>它最主要是负责数据的准备，也就是准备后面的阶段 所需的数据，像如模型，贴图，光照，相机位置等信息。</p><p>-————————————————————————————————————</p><p><strong>几何阶段（The Geometry Stage） GPU</strong></p><p><strong>顶点着色：</strong>可编程部分，顾名思义，它会对逐个顶点相关的信息进行处理，生成图元，计算并传递给接下来的渲染流程。就像我们平时切菜一样，这个阶段就是为了控制食材的形态，</p><p>它对应的则是这里的VertxShader，它的工作主要是计算顶点的位置、法线、纹理坐标，根据材质、纹理、以及光源属性进行顶点光照的计算，平时常见的顶点动画一般就是在这里实现的。</p><p>[ <strong>图元：</strong>可以简单理解为它是渲染管线中所有点，线，面的统称 ]</p><p><strong>几何着色：</strong> 可选可编程部分，并非所有GPU都支持 ，它可以把简单的图元拓展成更复杂的形式，通常我们认为，这两大着色器共同构成了 几何阶段的可编程部分。</p><p><strong>裁剪 ：</strong> 固定功能硬件实现，对顶点几何两大着色器的输出结果进行处理，它会把完全处于视锥体交界外  以及屏幕窗口外的 几何体部分裁剪掉， 只留下用户能看到的部分，并且对生成的新顶点部分进行插值，输送给接下来的阶段。</p><p>-—————————————————————————-</p><p><strong>光栅化阶段（Rasterization）</strong> <strong>GPU</strong></p><p><strong>屏幕映射：</strong>经过裁剪之后，硬件会通过透视除法将物体从 裁剪空间 变换 为 标准化设备坐标也叫<strong>NDC</strong>，之后GPU会把得到的NDC空间坐标下的顶点，映射到屏幕空间坐标中，进行图元装配，这一步会计算微分、边方程和其他三角形数据，三角形的朝向剔除就是在这个阶段完成的。</p><p><strong>NDC：</strong>全称Normalized Device Coordinates，一般来说裁剪完成后，会通过透视除法，将物体从裁剪空间 变换为标准化设备坐标NDC，透视除法是将裁剪空间中，顶点的4个分量都除以w分量，从裁剪空间转换到NDC。它是一个长宽高取值范围为[-1,1]的立方体，之所以要转到NDC，是为了方面我们后面进行视口变换把它映射到屏幕空间，不过Unity已经帮我们都完成这些啦，所以具体的数学推算这里不做讲解，有需要的小伙伴这里推荐大家看一下闫令琪老师的 <a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门 (ucsb.edu)</a> </p><p><img src="https://i0.hdslb.com/bfs/album/99cf906696753635d4107a22be180744e350800d.png" alt="img"></p><p>Vertex Shader -&gt; Clip Space -&gt; 透视除法 -&gt; NDC -&gt; 视口变换 -&gt; Screen Space -&gt; Fragment Shader</p><p><strong>图元装配：</strong></p><p>主要是计算微分（differentials）、边方程（edge equations）和其他三角形数据（顶点属性插值）</p><p><img src="https://i0.hdslb.com/bfs/album/6505944c2c06a91d617165002e765350f16c4c5b.png" alt="img"></p><p><strong>光栅化：</strong></p><p>它会在每个像素点上生成一个片元，如果开启了多重采样抗锯齿，就会对每个像素进行多次采样，产生多个片元，最终进行混合来达到抗锯齿的效果。</p><p>[ <strong>片元</strong>：是光栅化之后产生的像素点，因为没有被画到屏幕上，不能被直接称为像素一个像素的最终结果可能是由多个片元来决定的，渲染管线为了细分，就单独创造了片元这个词来描述它，片元只是渲染管线的概念 ]</p><p>[ <strong>像素</strong>：则是最后写到图像上的值 ]</p><p>-————————————————————————————————————</p><p><strong>像素处理阶段 （ Pixel Processing ）GPU</strong></p><p><strong>像素 (片元) 着色器：</strong>可编程部分，它的工作主要是根据顶点的插值属性，进行逐像素计算，因为它需要处理每一个像素，所以这也是最耗时的一个阶段。它的输入输出都是片元数据，输入的数据是 颜色 和纹理坐标，输出的则是计算后所得的每个像素的色彩值，像是逐像素光照、反射、阴影等等更为复杂的效果都是可以在这里实现的，这一步更像是再给我们的食材上色。</p><p><strong>合并：</strong>只可配置不可编程部分，在一系列的测试后会进行合并，所谓的测试则是判断一个像素点最终是否应该被显示在屏幕上，通过测试的颜色会和缓冲区的颜色叠加混合。</p><p>-————————————————————————————————————</p><p><strong>坐标空间</strong></p><p><strong>模型空间</strong> 以物体本身为原点的坐标空间，<strong>世界空间</strong>以世界的(0,0)为原点的坐标空间，<strong>视图空间</strong> 以相机为原点的坐标空间，描述的物体在相机的哪个位置，<strong>裁剪空间</strong>  顶点坐标乘以MVP矩阵之后所在的空间，<strong>屏幕空间</strong> 窗口屏幕上的二维像素坐标空间。</p><p><img src="https://i0.hdslb.com/bfs/album/01722d512b46b7b086bd0802f154e498900c98d0.png" alt="img"></p><p>-————————————————————————————————————</p><h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3><p><strong>Shader</strong>比较学术的百科回答就是用来实现图像渲染的，用来替代固定渲染管线的可编辑程序。其中Vertex Shader（顶点着色器）主要负责顶点的几何关系等的运算，Pixel Shader（像素着色器）主要负责片元颜色等的计算。</p><p><strong>Unity中的Shader类型</strong></p><p><img src="https://i0.hdslb.com/bfs/album/cf264f9d9f2eac7d414542e98c055aad7ae514c8.png" alt="img"></p><p><strong>Standard Surface Shader</strong></p><p>标准表面着色器，它是一种基于物理的着色系统，可以理解为 它是通过对物理现象的简单模拟，可以实现生活中各种物品的效果，比如石头、木材、玻璃、塑料和金属等等。</p><p><strong>Unlit Shader</strong></p><p>它是最简单的着色器，与 Standard Surface Shader 相比，它去除了冗长的光照公式以及阴影解算，因此得名 Unlit，翻译过来就是无光照，也正因如此，它只由最基础的 Vertex Shader 和 Fragment Shader 组成，最为基础易懂。</p><p><strong>Image Effect Shader</strong></p><p>它其实也是也是顶点片元着色器，不过它主要针对实现各种屏幕后处理效果，那后处理是什么呢？一般像是泛光、调色、景深、模糊等基于最终整个屏幕画面而进行再次处理的就是后处理，这里做个简单的了解即可。</p><p><strong>Compute Shader</strong></p><p>计算着色器，它是在GPU中运行的一段程序，独立于常规渲染管线之外的，它可以直接将GPU作为并行处理器加以利用，从而使GPU不仅具有3D渲染能力，还具有其他的运算能力。一般会在需要大量并行计算的时候使用。</p><p><strong>Ray Tracing Shader</strong></p><p>光线追踪着色器，光线追踪是指从摄像机出发的若干条光线，每条光线会和场景里的物体求交，根据交点位置获取表面的材质、纹理等信息，并结合光源信息计算光照。相对于传统的光栅化渲染，光线追踪可以轻松模拟各种光学效果，如反射、折射、散射、色散等。但由于在进行求交计算时需要知道整个场景的信息，它的计算成本也是非常高的。</p><p>-————————————————————————————————————</p><p><strong>ShaderLab</strong></p><p>Unity为我们封装的着色器语言，而目前主流的着色器语言有3种，基于OpenGL的<strong>GLSL</strong> &#x2F; 基于DX的<strong>HLSL</strong>  &#x2F;  NVIDIA公司的<strong>CG</strong>。</p><p>GLSL与HLSL分别是基于OpenGL和Direct3D的接口，两者不能混用。而CG则是为了使图形硬件的编程变得和 C语言编程一样方便自由，它本身基于C语言。如果你之前使用过C系语言其中的任意一个，那CG的语法也是比较容易掌握的。但其实由于Microsoft和NVIDIA的相互协作，他们在标准硬件光照语言的语法和语义上达成了一致，所以HLSL和Cg其实可以看为是同一种语言。</p><p>而<strong>ShaderLab</strong>则是Unity在HLSL和CG的基础之上封装的只属于Unity的着色器语言，它的灵活性更高，而且不再需要将 Shader 的配置 硬写在引擎代码中，本质是在底层着色语言的基础上，额外提供了声明信息，以数据驱动的方式使我们在渲染管线内自由发挥。</p><p>-—————————————————————————-</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">// Shader 的路径名称  默认为文件名,也可以与文件名不同</span><br><span class="line">Shader &quot;Unlit/HiShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    // 属性 </span><br><span class="line">    // Material Inspector显示的所有参数都在需要在这里进行声明</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        // 通常所有属性名都以下划线字符开头 _MainTex</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        // 比较常见的属性类型</span><br><span class="line">        // ————————————————————————————————————————————————</span><br><span class="line">        //_Integer (&quot;整数(新版)&quot;, Integer) = 1</span><br><span class="line">        _Int (&quot;整数(旧版)&quot;, Int) = 1</span><br><span class="line">        _Float (&quot;浮点数&quot;, Float) = 0.5</span><br><span class="line">        _FloatRange (&quot;浮点数滑动条&quot;, Range(0.0, 1.0)) = 0.5</span><br><span class="line">        // Unity包含以下内置纹理, 可以直接填充</span><br><span class="line">        // “white”（RGBA：1,1,1,1）</span><br><span class="line">        // “black”（RGBA：0,0,0,1）</span><br><span class="line">        // “gray”（RGBA：0.5,0.5,0.5,1）</span><br><span class="line">        // “bump”（RGBA：0.5,0.5,1,0.5）</span><br><span class="line">        // “red”（RGBA：1,0,0,1）</span><br><span class="line">        _Texture2D (&quot;2D纹理贴图&quot;, 2D) = &quot;red&quot; &#123;&#125;</span><br><span class="line">        // 字符串留空或输入无效值，则它默认为 “gray”</span><br><span class="line">        _DefaultTexture2D (&quot;2D纹理贴图&quot;, 2D) = &quot;&quot; &#123;&#125;</span><br><span class="line">        // 默认值为 “gray”（RGBA：0.5,0.5,0.5,1）</span><br><span class="line">        _Texture3D (&quot;3D纹理贴图&quot;, 3D) = &quot;&quot; &#123;&#125;</span><br><span class="line">        _Cubemap (&quot;立方体贴图&quot;, Cube) = &quot;&quot; &#123;&#125;</span><br><span class="line">        // Inspector会显示四个单独的浮点数字段</span><br><span class="line">        _Vector (&quot;Example vector&quot;, Vector) = (0.25, 0.5, 0.5, 1)</span><br><span class="line">        // Inspector会显示拾色器拾取色彩RGBA值</span><br><span class="line">        _Color(&quot;色彩&quot;, Color) = (0.25, 0.5, 0.5, 1)</span><br><span class="line">        // ————————————————————————————————————————————————</span><br><span class="line">        </span><br><span class="line">        // 除此之外 属性声明还可以具有一个可选特性 用来告知Unity如何处理它们</span><br><span class="line">        // HDR可以使色彩亮度的值超过1</span><br><span class="line">        [HDR]_HDRColor(&quot;HDR色彩&quot;, Color) = (1,1,1,1)</span><br><span class="line">        // Inspector隐藏此属性</span><br><span class="line">        [HideInInspector]_Hide(&quot;看不见我~&quot;, Color) = (1,1,1,1)</span><br><span class="line">        // Inspector隐藏此纹理属性的Scale Offset字段</span><br><span class="line">        [NoScaleOffset]_HideScaleOffset(&quot;隐藏ScaleOffset&quot;, 2D) = &quot;&quot; &#123;&#125;</span><br><span class="line">        // 指示纹理属性为法线贴图，如果分配了不兼容的纹理，编辑器则会显示警告。</span><br><span class="line">        [Normal]_Normal(&quot;法线贴图&quot;, 2D) = &quot;&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 子着色器 </span><br><span class="line">    // 一个Shader至少有一个或者多个子着色器SubShader，这些子着色器互不干扰，且只有一个会运行</span><br><span class="line">    // 在加载shader时Unity会遍历所有SubShader列表，并最终选择用户机器支持的第一个</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        // 可以通过Tags来向子着色器分配标签</span><br><span class="line">        // 只可以写在SubShader语块内,不可写在Pass内</span><br><span class="line">        /* 以键值对的形式存在,可以出现多个键值对</span><br><span class="line">        Tags &#123; </span><br><span class="line">            &quot;TagName1&quot; = &quot;Value1&quot;</span><br><span class="line">            &quot;TagName2&quot; = &quot;Value2&quot;</span><br><span class="line">            &quot;TagName3&quot; = &quot;Value3&quot;</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        // RenderPipeline: 声明子着色器是否与通用渲染管线 (URP) 或高清渲染管线 (HDRP) 兼容</span><br><span class="line">        // 仅与 URP 兼容</span><br><span class="line">        // Tags &#123; &quot;RenderPipeline&quot;=&quot;UniversalRenderPipeline&quot; &#125;</span><br><span class="line">        // 仅与 HDRP 兼容</span><br><span class="line">        // Tags &#123; &quot;RenderPipeline&quot;=&quot;HighDefinitionRenderPipeline&quot; &#125;</span><br><span class="line">        // RenderPipeline不声明或任何其他值表示与 URP 和 HDRP 不兼容</span><br><span class="line">        // ————————————————————————————————————————————————</span><br><span class="line">        </span><br><span class="line">        // Queue: 声明渲染队列</span><br><span class="line">        // Tags &#123; &quot;Queue&quot;=&quot;Background&quot; &#125; // 最早被调用的渲染，用来渲染天空盒或者背景</span><br><span class="line">        // Tags &#123; &quot;Queue&quot;=&quot;Geometry&quot; &#125;   // 这是默认值，用来渲染非透明物体（普通情况下，场景中的绝大多数物体应该是非透明的）</span><br><span class="line">        // Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &#125;  // 用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑</span><br><span class="line">        // Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &#125;// 以从后往前的顺序渲染透明物体</span><br><span class="line">        // Tags &#123; &quot;Queue&quot;=&quot;Overlay&quot; &#125;    // 用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）</span><br><span class="line">        // ————————————————————————————————————————————————</span><br><span class="line">        </span><br><span class="line">        // RenderType: 用来区别这个Shader要渲染的对象是属于什么类别的。</span><br><span class="line">        // 设置渲染类型 用一种称为着色器替换的技术在运行时交换子着色器,用来区别这个Shader要渲染的对象是属于什么类别的</span><br><span class="line">        // 这里表示非透明物体渲染</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        // 更多详细内容可参考官网文档 https://docs.unity.cn/cn/2021.3/Manual/SL-SubShaderTags.html</span><br><span class="line">        </span><br><span class="line">        // LOD (Level of Detail)</span><br><span class="line">        LOD 100</span><br><span class="line"></span><br><span class="line">        // 每个子着色器由多个通道组成，许多简单的着色器只使用一个通道，但想要一些更复杂的效果，着色器可能需要更多通道</span><br><span class="line">        // 一个Pass就是一次绘制，可以看成是一个Draw Call而Pass的意义在于多次渲染，</span><br><span class="line">        // 如果你有一个Pass，那么着色器只会被调用一次，如果你有多个Pass的话，</span><br><span class="line">        // 那么就相当于执行多次SubShader了，这就叫双通道或者多通道。</span><br><span class="line">        </span><br><span class="line">        // Draw Call：其实就是CPU调用图像编程接口的渲染命令，CPU每次调用DrawCall，都需要向GPU发送许多数据啊、渲染状态等等，</span><br><span class="line">        // 一旦CPU执行完应用阶段，GPU就会开始执行这次的渲染流程。而GPU渲染的速度比CPU提交命令的速度要快的多，</span><br><span class="line">        // 所以如果DrawCall数量过多的情况下，CPU需要进行大量的计算，进而就会导致CPU过载，影响游戏的运行效率。</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            // 声明顶点着色器</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            // 声明像素着色器</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // 使雾生效</span><br><span class="line">            #pragma multi_compile_fog</span><br><span class="line"></span><br><span class="line">            // 引用CG的核心代码库</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            // 应用程序阶段结构体</span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                // 参考：https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics</span><br><span class="line">                // POSITION 着色器语言的语义，用来限定着色器的输入输出值的类型</span><br><span class="line">                // 模型空间的顶点坐标</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                // 模型的第一套UV坐标</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                // UV</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(1)</span><br><span class="line">                // SV_POSITION 当这个值需要作为输出值输出给系统用的时候 前面需要加SV_前缀</span><br><span class="line">                // 当然因为有向下兼容的机制 不加也没啥太大问题</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            // 在Properties中声明的参数要在这里相对应的定义后才可以使用</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            // 定义顶点着色器函数 函数名要与声明顶点着色器名称相同</span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                // 将顶点坐标从模型空间变换到裁剪空间</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                // Transforms 2D UV by scale/bias property</span><br><span class="line">                // #define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)</span><br><span class="line">                // 等价于v.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                // 简单来说，TRANSFORM_TEX主要作用是拿顶点的uv去和材质球的tiling和offset作运算，</span><br><span class="line">                // 确保材质球里的缩放和偏移设置是正确的</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // SV_Target可以视为COLOR ，虽说他也是作为输出值输出给系统的</span><br><span class="line">            // 但它其实是告诉系统把输出的颜色值存储到RenderTarget中</span><br><span class="line">            // 所以这里我们用SV_Target</span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // 采样2D纹理贴图</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                // 应用雾</span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                // 返回经过处理后的最终色彩</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="VertexShader"><a href="#VertexShader" class="headerlink" title="VertexShader"></a><strong>VertexShader</strong></h4><p>找到 VertexShader，这里将通过调整顶点的 Y 轴位置实现一个简单的压扁效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">         v2f o;</span><br><span class="line">         o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">         // 模型空间转到世界空间</span><br><span class="line">         float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">         // 压Y轴位置 这里把世界空间下顶点的y减去最低部y的值乘上一个系数</span><br><span class="line">         // 然后再用y去减去这个值，就可以通过这个系数来控制兔子被压扁的程度</span><br><span class="line">         float y = worldPos.y - (worldPos.y - _Bottom) * _Value;</span><br><span class="line">         // 最终世界空间位置</span><br><span class="line">         float3 tempWorld = float3(worldPos.x,y,worldPos.z);</span><br><span class="line">         // 世界空间转裁剪空间</span><br><span class="line">         o.vertex = UnityWorldToClipPos(tempWorld);</span><br><span class="line">         return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Value (&quot;压扁系数&quot;,Range(0, 1)) = 0</span><br><span class="line">    _Bottom (&quot;底部&quot;, float) = 0</span><br><span class="line">&#125;</span><br><span class="line">                                        </span><br><span class="line">    float _Value;</span><br><span class="line">    float _Bottom;</span><br></pre></td></tr></table></figure><p>最后拖拽压扁系数条就可以看到效果啦~</p><p><img src="https://i0.hdslb.com/bfs/album/32ec164f24a28bf21e8e9e37d1e8b71f3bbbdedf.png" alt="img"></p><p>-—————————————————————————-</p><h4 id="Pixel-Shader"><a href="#Pixel-Shader" class="headerlink" title="Pixel Shader"></a><strong>Pixel Shader</strong></h4><p>这里创建一个 Cube，相比之下，虽然它们都是三维模型，但这只兔子看起来就跟纸片一样，完全没有立体感。</p><p><img src="https://i0.hdslb.com/bfs/album/2d1cfe8099c288c7ea64989b9f60908958d168e8.png" alt="img"></p><p>这是因为 Unlit 默认是不受光材质，纹理什么颜色它就直接显示出来了，但通常来说，光照是三维世界不可或缺的部分，现实世界中，当光照射到物体表面时, 物体对光会发生反射、透射、吸收、折射等被物体反射的光进入视觉系统，使看见物体的表面有明暗之分，为了模拟这一现象，科研家建立了一些数学模型来替代复杂的物理模型，统称为光照模型。</p><p><img src="https://i0.hdslb.com/bfs/album/b21d48732de734ec0bfa5c99a1e88762ca9dc4c1.png" alt="img"></p><p>比较常见的光照模型有漫反射的 Half Lambert 模型 ，以及镜面反射的 Blinn-Phong 模型。 Half Lambert 能够较好地表现粗糙表面上的光照现象，像如石灰墙，纸张等等，但是在渲染金属材质制成的物体时，则会显得呆板，表现不出光泽。主要原因是其没有考虑到镜面反射效果，所以 Blinn-Phong 对其进行了很好的补充。</p><p><img src="https://i0.hdslb.com/bfs/album/ba37e767152d5056072e8609c29f5b59575b8bc9.png" alt="img"></p><p>这里我们将通过Pixel Shader实现最简单的 Half Lambert ，首先拿到计算光照需要的模型法线和世界坐标，在v2f的结构体里将它们进行定义，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">     float2 uv : TEXCOORD0;</span><br><span class="line">                                                </span><br><span class="line">     // 计算光照需要用到法线和世界位置</span><br><span class="line">     // 通常使用TEXCOORDn语义来修饰float2, float3, float4类型</span><br><span class="line">     float3 worldNormal: TEXCOORD1;</span><br><span class="line">     float3 worldPos:TEXCOORD2;</span><br><span class="line">                                                </span><br><span class="line">     UNITY_FOG_COORDS(1)</span><br><span class="line">     float4 vertex : SV_POSITION;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在顶点着色器中将世界坐标和法线进行处理，传递给接下来的像素着色器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    // 模型空间转到世界空间</span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    // 法线向量归一化</span><br><span class="line">    o.worldNormal = normalize(UnityObjectToWorldNormal(v.normal));</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在像素着色器中，首先通过世界坐标拿到光照的方向，也就是所谓的入射光，用法线点乘入射光，就可以得到入射光与模型表面的夹角，由于当入射光和法线夹角的余弦值为负数的时候，所得到的结果始终都是零，就会导致照不到的地方一片漆黑，所以这里需要乘0.5再加0.5 ，这样就可以把原本-1到1的取值范围变为0-1的取值范围。最后把求出来的光照亮度叠加到最终的像素色彩值就可以啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">     // sample the texture</span><br><span class="line">     fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">     // 得到光照方向</span><br><span class="line">     float3 worldLightDir = UnityWorldSpaceLightDir(i.worldPos);</span><br><span class="line">     // NoL代表表面接受的能量大小</span><br><span class="line">     float NoL = dot(i.worldNormal, worldLightDir);</span><br><span class="line">     // 计算half-lambert亮度值</span><br><span class="line">     float halfLambert = NoL * 0.5 + 0.5;</span><br><span class="line">     // apply fog</span><br><span class="line">     UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">     return col * halfLambert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样最终的效果就会更符合我们的视觉观感。</p><p><img src="https://i0.hdslb.com/bfs/album/1f32d59025b3c2739b58c9dedec1fc4a524a5fd2.png" alt="img"></p><h2 id="3-卡通渲染"><a href="#3-卡通渲染" class="headerlink" title="3.卡通渲染"></a>3.卡通渲染</h2><p><strong>NPR</strong> 是  Non-Photorealistic Rendering 的简称，也就是图形渲染中的非真实感渲染，常见的 NPR 渲染包括卡通渲染、油画渲染、像素感渲染、素描画、水墨画等类型，</p><p><strong>卡通渲染</strong> 是非真实感渲染中应用最广的渲染技术，在游戏和影视领域都是非常常见的。它主要是通过简化并剔除画面原本所包含的混杂部分，给人以独特的感染力和童趣，通常来说卡通渲染有4个要素 轮廓描边、色阶、高光、边缘光</p><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p><strong>轮廓描边</strong></p><p><img src="https://i0.hdslb.com/bfs/album/9722f2aa43133b2a6047bdb9fb3ff8e5e4732d7a.png" alt="img"></p><p> 渲染轮廓线的方式有很多种, 在这里带大家熟悉其中最简单的一种, 对物体做两次渲染， 第二次渲染时开启正面剔除，将顶点沿法线向外延深一段距离，（放大物体），实现轮廓线，这里就用到我们之前提到的多Pass渲染。</p><p>打开ToonShader，首先在Properties语块中声明轮廓线相关的两个属性，方便我们进行之后的调整：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_MainTex(&quot;Texture&quot;,2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">_OutlineWidth (&quot;Outline Width&quot;, Range(0.01, 1)) = 0.01</span><br><span class="line">_OutLineColor (&quot;OutLine Color&quot;, Color) = (0.5,0.5,0.5,1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本的pass我们暂时先不用动，直接新增一个Pass来做轮廓线的渲染，这里记得定义一下我们刚刚声明的宽度和颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/ToonShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _OutlineWidth (&quot;Outline Width&quot;, Range(0.01, 1)) = 0.01</span><br><span class="line">   _OutLineColor (&quot;OutLine Color&quot;, Color) = (0.5,0.5,0.5,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD 100</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fog</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(1)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // sample the texture</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                // apply fog</span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;  </span><br><span class="line">       // 开启前向剔除 表示剔除前面 只显示背面</span><br><span class="line">            Cull Front</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            </span><br><span class="line">            // 线条宽度</span><br><span class="line">            float _OutlineWidth;</span><br><span class="line">            // 线条颜色</span><br><span class="line">            float4 _OutLineColor;</span><br><span class="line"></span><br><span class="line">            struct appdata </span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                // 法线</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">      float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v) </span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">      // 顶点沿着法线方向外扩(放大模型)</span><br><span class="line">      float4 newVertex = float4(v.vertex.xyz + v.normal * _OutlineWidth * 0.01 ,1);</span><br><span class="line">      // UnityObjectToClipPos(v.vertex) 将模型空间下的顶点转换到齐次裁剪空间</span><br><span class="line">                o.vertex = UnityObjectToClipPos(newVertex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half4 frag(v2f i) : SV_TARGET </span><br><span class="line">            &#123;</span><br><span class="line">           // 返回线条色彩</span><br><span class="line">                return _OutLineColor;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们的第一步轮廓描边就做好了 </p><p> -———————————————————————————————————— </p><p><strong>色阶</strong></p><p><img src="https://i0.hdslb.com/bfs/album/c3299217e20dddade61d8644f6c6f328b365e717.png" alt="img"></p><p>通常来说都是由它来决定画面色彩的丰富度饱满度精细度，而大部分卡通渲染习惯降低色阶，用简单的明暗关系来描述世界，使画面扁平又不失层次感，这里还是用上节讲的half Lambert光照模型，不过这看起来一点都不卡通，我们需要让它明暗分明一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 得到顶点法线</span><br><span class="line">float3 normal = normalize(i.worldNormal);</span><br><span class="line">// 得到光照方向</span><br><span class="line">float3 worldLightDir = UnityWorldSpaceLightDir(i.worldPos);</span><br><span class="line">// NoL代表表面接受的能量大小</span><br><span class="line">float NoL = dot(i.worldNormal, worldLightDir);</span><br><span class="line">// 计算half-lambert亮度值</span><br><span class="line">float halfLambert = NoL * 0.5 + 0.5;</span><br><span class="line"></span><br><span class="line">// 通过亮度值计算线性ramp</span><br><span class="line">float ramp = linearstep(_RampStart, _RampStart + _RampSize, halfLambert);</span><br><span class="line">float step = ramp * _RampStep;  // 使每个色阶大小为1, 方便计算</span><br><span class="line">float gridStep = floor(step);   // 得到当前所处的色阶</span><br><span class="line">float smoothStep = smoothstep(gridStep, gridStep + _RampSmooth, step) + gridStep;</span><br><span class="line">ramp = smoothStep / _RampStep;  // 回到原来的空间</span><br><span class="line">// 得到最终的ramp色彩</span><br><span class="line">float3 rampColor = lerp(_DarkColor, _LightColor, ramp);</span><br><span class="line">rampColor *= col;</span><br></pre></td></tr></table></figure><p><strong>高光</strong></p><p><img src="https://i0.hdslb.com/bfs/album/1bdc2e7030f240036a6e380882e2a52ac1b0c6f7.png" alt="img"></p><p>那上节讲过half lambert  它是漫反射，而漫反射是没有考虑高光的，所以这里我们需要用blinnphone来做镜面反射。</p><p>用相机的位置减去世界位置得到视向量，也就是当前物体表面指向摄像机的方向，由于反射不太好算，所以这里通过 视向量 和 光照方向 得到角平分线，也就是半程向量。通过 法线方向 点乘 半程向量 就可以得到 法线 和 半程向量 的 夹角，由此就 可以推断出 视向量 和 反射向量 的 接近程度，用 noh 来 计算高光 的 亮度值，而这个参数 SpecPow 则是 控制高光的 光泽度，也就是 高光 亮斑的 范围，和色阶同样，用smoothStep来做个柔边的效果再把高光颜色和强度值加上，最后我们把漫反射和高光混合，就可以来调试效果啦。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 得到视向量</span><br><span class="line">float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">// 计算half向量, 使用Blinn-phone计算高光</span><br><span class="line">float3 halfDir = normalize(viewDir + worldLightDir);</span><br><span class="line">// 计算NoH用于计算高光</span><br><span class="line">float NoH = dot(normal, halfDir);</span><br><span class="line">// 计算高光亮度值</span><br><span class="line">float blinnPhone = pow(max(0, NoH), _SpecPow * 128.0);</span><br><span class="line">// 计算高光色彩</span><br><span class="line">float3 specularColor = smoothstep(0.7 - _SpecSmooth / 2, 0.7 + _SpecSmooth / 2, blinnPhone) </span><br><span class="line">                                             * _SpecularColor * _SpecIntensity;</span><br></pre></td></tr></table></figure><p><strong>边缘光</strong></p><p><img src="https://i0.hdslb.com/bfs/album/811189c19dcdb594ca48c5f4f41b0770d6a777c9.png" alt="img"></p><p>首先我们需要得知哪里是我们看到的边缘，当我们的视向量和法线向量的夹角越接近直角时它就越靠近边缘，先拿到视向量和法向量的夹角，就可以看到，越是接近边缘的地方越暗，但边缘光一般都是越接近边缘越亮，所以给 1- 反转一下，但正常来说阴影部分是不应该有边缘光的，所以要把漫反射加一下，那到至此边缘光就正确啦~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 计算NoV用于计算边缘光</span><br><span class="line">float NoV = dot(i.worldNormal, viewDir);</span><br><span class="line">// 计算边缘光亮度值</span><br><span class="line">float rim = (1 - max(0, NoV)) * NoL;</span><br><span class="line">// 计算边缘光颜色</span><br><span class="line">float3 rimColor = smoothstep(_RimThreshold - _RimSmooth / 2, _RimThreshold + _RimSmooth / 2, rim) * _RimColor;</span><br></pre></td></tr></table></figure><p>最后把各项颜色混合就大功告成啦~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 混合颜色</span><br><span class="line">float3 finalColor = saturate(rampColor + specularColor + rimColor);</span><br><span class="line">return float4(finalColor,1);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/album/0027e4cb3bdccdd2c29f24b92ffb9daa0f2829f1.png" alt="img"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/ToonShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        _OutlineWidth (&quot;Outline Width&quot;, Range(0.01, 1)) = 0.01</span><br><span class="line">      _OutLineColor (&quot;OutLine Color&quot;, Color) = (0.5,0.5,0.5,1)</span><br><span class="line">        </span><br><span class="line">        _RampStart (&quot;交界起始 RampStart&quot;, Range(0.1, 1)) = 0.3</span><br><span class="line">        _RampSize (&quot;交界大小 RampSize&quot;, Range(0, 1)) = 0.1</span><br><span class="line">        [IntRange] _RampStep(&quot;交界段数 RampStep&quot;, Range(1,10)) = 1</span><br><span class="line">        _RampSmooth (&quot;交界柔和度 RampSmooth&quot;, Range(0.01, 1)) = 0.1</span><br><span class="line">        _DarkColor (&quot;暗面 DarkColor&quot;, Color) = (0.4, 0.4, 0.4, 1)</span><br><span class="line">        _LightColor (&quot;亮面 LightColor&quot;, Color) = (0.8, 0.8, 0.8, 1)</span><br><span class="line">        </span><br><span class="line">        _SpecPow(&quot;SpecPow 光泽度&quot;, Range(0, 1)) = 0.1</span><br><span class="line">        _SpecularColor (&quot;SpecularColor 高光&quot;, Color) = (1.0, 1.0, 1.0, 1)</span><br><span class="line">        _SpecIntensity(&quot;SpecIntensity 高光强度&quot;, Range(0, 1)) = 0</span><br><span class="line">        _SpecSmooth(&quot;SpecSmooth 高光柔和度&quot;, Range(0, 0.5)) = 0.1</span><br><span class="line">        </span><br><span class="line">        _RimColor (&quot;RimColor 边缘光&quot;, Color) = (1.0, 1.0, 1.0, 1)</span><br><span class="line">        _RimThreshold(&quot;RimThreshold 边缘光阈值&quot;, Range(0, 1)) = 0.45</span><br><span class="line">        _RimSmooth(&quot;RimSmooth 边缘光柔和度&quot;, Range(0, 0.5)) = 0.1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD 100</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal: NORMAL;  // 计算光照需要用到模型法线</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                // 计算光照需要用到法线和世界位置</span><br><span class="line">                float3 worldNormal: TEXCOORD1;</span><br><span class="line">                float3 worldPos:TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float _RampStart;</span><br><span class="line">            float _RampSize;</span><br><span class="line">            float _RampStep;</span><br><span class="line">            float _RampSmooth;</span><br><span class="line">            float3 _DarkColor;</span><br><span class="line">            float3 _LightColor;</span><br><span class="line"></span><br><span class="line">            float _SpecPow;</span><br><span class="line">            float3 _SpecularColor;</span><br><span class="line">            float _SpecIntensity;</span><br><span class="line">            float _SpecSmooth;</span><br><span class="line"></span><br><span class="line">            float3 _RimColor;</span><br><span class="line">            float _RimThreshold;</span><br><span class="line">            float _RimSmooth;</span><br><span class="line"></span><br><span class="line">            float linearstep (float min, float max, float t)</span><br><span class="line">            &#123;</span><br><span class="line">                return saturate((t - min) / (max - min));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                // 向下传输这些数据</span><br><span class="line">                o.worldNormal = normalize(UnityObjectToWorldNormal(v.normal));</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // sample the texture</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                //------------------------ 漫反射 ------------------------</span><br><span class="line">                // 得到顶点法线</span><br><span class="line">                float3 normal = normalize(i.worldNormal);</span><br><span class="line">                // 得到光照方向</span><br><span class="line">                float3 worldLightDir = UnityWorldSpaceLightDir(i.worldPos);</span><br><span class="line">                // NoL代表表面接受的能量大小</span><br><span class="line">                float NoL = dot(i.worldNormal, worldLightDir);</span><br><span class="line">                // 计算half-lambert亮度值</span><br><span class="line">                float halfLambert = NoL * 0.5 + 0.5;</span><br><span class="line"></span><br><span class="line">                //------------------------ 高光 ------------------------</span><br><span class="line">                // 得到视向量</span><br><span class="line">                float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                // 计算half向量, 使用Blinn-phone计算高光</span><br><span class="line">                float3 halfDir = normalize(viewDir + worldLightDir);</span><br><span class="line">                // 计算NoH用于计算高光</span><br><span class="line">                float NoH = dot(normal, halfDir);</span><br><span class="line">                // 计算高光亮度值</span><br><span class="line">                float blinnPhone = pow(max(0, NoH), _SpecPow * 128.0);</span><br><span class="line">                // 计算高光色彩</span><br><span class="line">                float3 specularColor = smoothstep(0.7 - _SpecSmooth / 2, 0.7 + _SpecSmooth / 2, blinnPhone)</span><br><span class="line">                                        * _SpecularColor * _SpecIntensity;</span><br><span class="line"></span><br><span class="line">                //------------------------ 边缘光 ------------------------</span><br><span class="line">                // 计算NoV用于计算边缘光</span><br><span class="line">                float NoV = dot(i.worldNormal, viewDir);</span><br><span class="line">                // 计算边缘光亮度值</span><br><span class="line">                float rim = (1 - max(0, NoV)) * NoL;</span><br><span class="line">                // 计算边缘光颜色</span><br><span class="line">                float3 rimColor = smoothstep(_RimThreshold - _RimSmooth / 2, _RimThreshold + _RimSmooth / 2, rim) * _RimColor;</span><br><span class="line"></span><br><span class="line">                //------------------------ 色阶 ------------------------</span><br><span class="line">                // 通过亮度值计算线性ramp</span><br><span class="line">                float ramp = linearstep(_RampStart, _RampStart + _RampSize, halfLambert);</span><br><span class="line">                float step = ramp * _RampStep;  // 使每个色阶大小为1, 方便计算</span><br><span class="line">                float gridStep = floor(step);   // 得到当前所处的色阶</span><br><span class="line">                float smoothStep = smoothstep(gridStep, gridStep + _RampSmooth, step) + gridStep;</span><br><span class="line">                ramp = smoothStep / _RampStep;  // 回到原来的空间</span><br><span class="line">                // 得到最终的ramp色彩</span><br><span class="line">                float3 rampColor = lerp(_DarkColor, _LightColor, ramp);</span><br><span class="line">                rampColor *= col;</span><br><span class="line">                </span><br><span class="line">                // 混合颜色</span><br><span class="line">                float3 finalColor = saturate(rampColor + specularColor + rimColor);</span><br><span class="line">                return float4(finalColor,1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Cull Front</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                // 法线</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            // 线条宽度</span><br><span class="line">            float _OutlineWidth;</span><br><span class="line">            // 线条颜色</span><br><span class="line">            float4 _OutLineColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                float4 newVertex = float4(v.vertex.xyz +  normalize(v.normal) * _OutlineWidth * 0.05,1);</span><br><span class="line">                o.vertex = UnityObjectToClipPos(newVertex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return _OutLineColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fallback&quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Noise"><a href="#Noise" class="headerlink" title="Noise"></a>Noise</h2><p><strong>SkyBox</strong></p><p>Unity中天空的概念是，相机在渲染场景之前绘制的一种背景类型，它可以给场景提供深度感，使场景看上去比实际大小要大得多。</p><p>而天空本身可以包含任何无法触及的像如太阳月亮星星这些对象，来营造遥远的空间视觉感。本质上是把场景放置在天空的立方体内，在渲染场景前，Unity会首先渲染这个立方体由于是从里向外看，所以我们的天空永远在做背面渲染，那在Unity中通常将它称为SkyBox 天空盒。</p><p>其实在日常的开发中天空是被大多数人所忽略的一个部分，毕竟Unity默认已经准备好了一个还算可以的天空~ 但如果你不想要这千篇一律的效果，还可以通过Shader自定义更为别致的天空。</p><p><img src="https://i0.hdslb.com/bfs/album/ab381822e4031b011198c8c14e2e51f0347c77d6.png" alt="img"></p><p>这里我们新建一个Shader和Material，点击Windows-&gt; Rendering -&gt; Lighting -&gt; Environment</p><p><img src="https://i0.hdslb.com/bfs/album/63b1b0548923be86305835ab3041281d14921dc1.png" alt="img"></p><p>就可以看到配置SkyBoxMaterial的这一栏，替换成刚刚新建的材质就可以啦</p><p><img src="https://i0.hdslb.com/bfs/album/cc0c45a21adbe7b559e139c31e8a0813e8ea92a0.png" alt="img"></p><p>-————————————————————————————————————  </p><p><strong>RayMarch</strong> </p><p>它属于体积渲染技术，像如云呀雾呀等等这些，它们都是很难用几何体来表现的，所以一般会把效果抽象成大量的体积像素来进行渲染，当然极光也不例外，地球上的极光是由来自 磁层 和 太阳风 的 带电高能粒子 被 地磁场导引 带进地球的大气层，并与高层大气热层 中的 原子碰撞造成的发光现象，所以它也属体积物体的一类。</p><p><img src="https://i0.hdslb.com/bfs/album/8ef8bffd9ae3fd866bd598d71a9cc56779b7b8dc.png" alt="img"></p><p>所谓体积渲染，就是用3D离散采样数据集, 进行2D投影的过程，换句话说就是取体积物体的 一组2D切片纹理，进行多次叠加采样计算，得到最终的屏幕色彩值，可以想象成叠千层饼的感觉吧~</p><p>RayMarch中文的意思就是光线步进，可以简单理解为光线在一步一步的向前行进，核心理念呢就是以相机为原点，向屏幕上的每一个像素，发射一条射线，射线按照一定的步长向前步进，这个所谓的步长呢，就是每步的Size，检测当前光线与物体表面之间的距离 然后根据这个距离 调整光线的步长，直到抵达物体的表面，每向前步进一次 都会累积计算一些 我们所需的信息，当步进到某个状态的时侯，结束步进，根据最终返回的累积数据，对屏幕上的像素进行绘制</p><p><img src="https://i0.hdslb.com/bfs/album/0403c68484f12aa6163d73b8d630dc37bab7a451.png" alt="img"></p><p>-————————————————————————————————————  </p><p><strong>Noise</strong></p><p>它其实就是图像中一种亮度或颜色信息的随机变化，也可以说是 计算机图形学 中一类 随机算法。通常我们会利用噪声算法，混合色彩贴图、高度贴图、法线贴图、UV贴图等，去构造模拟自然界中各式各样的物体表面的纹理材质细节，关于详细的噪声生成算法这里不做过多赘述，直接用生成好的噪声贴图进行采样就好啦~</p><p><img src="https://i0.hdslb.com/bfs/album/6973c9ffe888f0de979710a71e6f7e9dfbd87029.png" alt="img"></p><p>-————————————————————————————————————</p><h3 id="实战案例-极光"><a href="#实战案例-极光" class="headerlink" title="实战案例 - 极光"></a>实战案例 - 极光</h3><p><strong>模拟大气层</strong></p><p><img src="https://i0.hdslb.com/bfs/album/046e585b0d5f54eb07aaf78ca66792e70147b486.png" alt="img"></p><p>从0点开始向前发射一条射线，拿到射线的方向。极光一般都会产生在地球上空90-130千米处，所以接下来的本质其实是在模拟一个大气层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 计算ray march</span><br><span class="line">// 每个像素发射射线</span><br><span class="line">float3 rayOriginal = 0;</span><br><span class="line">float3 totalDir = i.worldPos - rayOriginal;</span><br><span class="line">float3 rayDir = normalize(totalDir);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/album/8ff8814d89f95e4cf0434f1419dfd660ee0620ab.png" alt="img"></p><p>用倒数函数来求一下天空的曲率值，当y越接近于零的时侯，它的x越大，这个层也就越接近一个平面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 拓展球面来计算march的起始点</span><br><span class="line">// rcp -&gt; reciprocal 求倒数</span><br><span class="line">// 天空曲率</span><br><span class="line">float skyCurvatureFactor = rcp(rayDir.y + _SkyCurvature);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/album/057ef9e25791f8989ec47de2ee770957fa3636e2.png" alt="img"></p><p>沿射线的方向向外延伸，把刚刚求出来的天空曲率乘上，那为了使极光的重复度更可控，我们在最后乘上一个平铺系数，那至此大气层的最底面就设定好啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 无数条射线像外发射 就会形成一个球面 *天空曲率 就可以把它拍成一个球</span><br><span class="line">float3 basicRayPlane = rayDir * skyCurvatureFactor * _AurorasTiling ;</span><br><span class="line">// 从哪开始步进(大气层最底面)</span><br><span class="line">float3 rayMarchBegin = rayOriginal + basicRayPlane;</span><br></pre></td></tr></table></figure><p><strong>光线步进</strong></p><p><img src="https://i0.hdslb.com/bfs/album/db94835dd317e3de7b46da65442c0dd6339cce7b.png" alt="img"></p><p>把模拟好的大气层底面作为步进的起始位置，同样在这里通过倒数函数算一下步长，步数越多，步的Size就越小，既然需要对每一步的信息进行累积计算，加一个for循环，为了使初始的几次采样 贡献更大, 所以可以用二次函数来着重一下初始采样，根据这个总距离求出当前的步进距离，根据射线方向和距离乘上天空曲率算出步进后的采样坐标。增加一个黑白贴图来决定极光的形状。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 一步的大小</span><br><span class="line">float stepSize = rcp(_RayMarchStep);</span><br><span class="line">for (float i = 0; i &lt; _RayMarchStep; i += 1)</span><br><span class="line">&#123;</span><br><span class="line">     float curStep = stepSize * i;</span><br><span class="line">     // 初始的几次采样贡献更大, 我们用二次函数着重初始采样</span><br><span class="line">     curStep = curStep * curStep;</span><br><span class="line">     // 当前步进距离</span><br><span class="line">     float curDistance = curStep * _RayMarchDistance;</span><br><span class="line">     // 步进后的位置</span><br><span class="line">     float3 curPos = rayMarchBegin + rayDir * curDistance * skyCurvatureFactor;</span><br><span class="line">     float2 uv = float2(-curPos.x,curPos.z);</span><br><span class="line">     float curAuroras = tex2D(_MainTex, TRANSFORM_TEX(uv, _MainTex)).r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>色彩渐变拖尾</strong></p><p><img src="https://i0.hdslb.com/bfs/album/153df8842e58d75c3f09b68c1ce1d0dc0b260f4c.png" alt="img"></p><p>首先在for循环内，拿设定的色彩做初相，由于sin的范围是-1到1，所以要先把色彩范围转换到-1到1之间，通过 i 计算出当前步进层的色彩，最后 * 0.5再加0.5就返回到了原本0-1的范围区间。取两步色彩的平均值，使当前步进层的颜色更接近于本色，最后把当前步进层的色彩累积上去使色彩混合，就可以看到最基础的极光拖尾渐变色啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 极光色彩累积计算</span><br><span class="line">// 由于sin的范围是-1到1，所以要先把颜色范围转换到-1到1之间，这通过i计算出当前步进层的色彩</span><br><span class="line"> // 最后 * 0.5再加0.5就返回到了原本的0-1的范围区间</span><br><span class="line"> float3 curColor = sin((_AurorasColor * 2 - 1) + i * 0.043) * 0.5 + 0.5;</span><br><span class="line">// 取两步色彩的平均值 使颜色更接近于本色 </span><br><span class="line">avgColor = (avgColor + curColor) / 2;</span><br><span class="line">                    </span><br><span class="line">// 混合颜色</span><br><span class="line">color += avgColor * curAuroras * stepSize;</span><br></pre></td></tr></table></figure><p>最后为了使色彩更为自然，增加一个强度衰减就大功告成啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// for 内</span><br><span class="line">// 强度衰减</span><br><span class="line">curAuroras = curAuroras * saturate(1 - pow(curDistance, 1 - _AurorasAttenuation));</span><br><span class="line"> // for 外</span><br><span class="line">// 强度</span><br><span class="line">color *= _AurorasIntensity;</span><br></pre></td></tr></table></figure><p><strong>动态极光</strong></p><p>为了使极光动起来，这里需要用神奇的噪声贴图来做个UV扰动，所谓的UV扰动，它的概念简单来说就是，给UV采样通过噪声做随机的偏移，首先把噪声贴图采出来，给它乘上一个时间维度和速度，就可以使噪声随着时间流逝动起来啦，既然是给原本的UV采样做随机偏移，所以这里把噪声偏移加上之后乘以一个系数就可以了~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// for 内</span><br><span class="line">// 计算扰动uv</span><br><span class="line">float2 warp_vec = tex2D(_AurorasNoiseTex,TRANSFORM_TEX((uv * 2 + _Time.y * _AurorasSpeed),_AurorasNoiseTex));</span><br><span class="line"> // 采样当前的噪声强度</span><br><span class="line">float curNoise = tex2D(_MainTex, TRANSFORM_TEX((uv + warp_vec * 0.1), _MainTex)).r;</span><br><span class="line">// 混合颜色</span><br><span class="line">color += avgColor * curNoise * stepSize;</span><br></pre></td></tr></table></figure><h3 id="实战案例-星空"><a href="#实战案例-星空" class="headerlink" title="实战案例 - 星空"></a>实战案例 - 星空</h3><p>同样这里还是用神奇的噪声贴图来做璀璨的漫天繁星，其实直接采噪声贴图就可以有较为粗糙的星星了，</p><p><img src="https://i0.hdslb.com/bfs/album/fd994705c2f4bf5b462e0110c3a1006d3b3e654e.png" alt="img"></p><p>但这并不是我们想要的效果，太多太密集了，而且它不会随机一闪一闪亮晶晶，那这里可以做两代星星的循环迭代，既然要做星星的闪动效果，所以需要给它增加一个时间维度乘上星星的闪烁速度，通过Time来计算叠加区间的两层星星UV，由于取整了之后UV加不加的没什么意义，所以这里给它乘个0.3的魔法值，然后通过偏移好的UV去采样两层星星值就好啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const float starTime = _Time.y * _StarShinningSpeed;</span><br><span class="line"></span><br><span class="line">// 计算叠加区间的两层星星UV</span><br><span class="line">const float2 beginMove = floor(starTime) * 0.3;</span><br><span class="line">const float2 endMove = ceil(starTime) * 0.3;</span><br><span class="line">const float2 beginUV = i.uv + beginMove;</span><br><span class="line">const float2 endUV = i.uv + endMove;</span><br><span class="line"></span><br><span class="line">// 采样两层星星的值</span><br><span class="line">float beginNoise = tex2D(_StarNoiseTex, TRANSFORM_TEX(beginUV,_StarNoiseTex)).r;</span><br><span class="line">float endNoise = tex2D(_StarNoiseTex, TRANSFORM_TEX(endUV,_StarNoiseTex)).r;</span><br></pre></td></tr></table></figure><p>那为了使星星的密度变得更为可控，我们给它增加一个StarCount来调整，这一步做的就是 假设当这个StarCount是0.1的时候只显示 最亮的百分之十的星星，剩下比较暗的不做显示。最后根据这个Time去把两层星星的值混合一下就好啦~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 减少星星</span><br><span class="line">                                         beginNoise = saturate(beginNoise - (1 - _StarCount)) / _StarCount;</span><br><span class="line">                                         endNoise = saturate(endNoise - (1 - _StarCount)) / _StarCount;</span><br><span class="line"></span><br><span class="line">                                         const float fracStarTime = frac(starTime);</span><br><span class="line">                                         // 混合两层星星值</span><br><span class="line">                                         starColor = saturate(beginNoise - fracStarTime) + saturate(endNoise - (1 - fracStarTime));</span><br></pre></td></tr></table></figure><p>最后为了使天空交界更为自然，加个天际线混合就大功告成啦~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 混合天际线</span><br><span class="line">color *= saturate(rayDir.y / _SkyLineSize + _SkyLineBasePow);</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Auroras&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;AurorasTexture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AurorasNoiseTex (&quot;AurorasNoise&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _StarNoiseTex (&quot;StarNoise&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _SkyColor (&quot;天空颜色 SkyColor&quot;, Color) = (0.4, 0.4, 0.4, 1)</span><br><span class="line">        _AurorasColor (&quot;极光颜色 AurorasColor&quot;, Color) = (0.4, 0.4, 0.4, 1)</span><br><span class="line">        _AurorasTiling(&quot;极光平铺 AurorasTiling&quot;, Range(0.1, 10)) = 0.4</span><br><span class="line">        _AurorasSpeed (&quot;极光变化速度 AurorasSpeed&quot;, Range(0.01, 1)) = 0.1</span><br><span class="line">        </span><br><span class="line">        _AurorasIntensity(&quot;极光强度 AurorasIntensity&quot;, Range(0.1, 20)) = 3</span><br><span class="line">        _AurorasAttenuation(&quot;极光衰减 AurorasAttenuation&quot;, Range(0, 0.99)) = 0.4</span><br><span class="line">        </span><br><span class="line">        _SkyCurvature (&quot;天空曲率 SkyCurvature&quot;, Range(0, 10)) = 0.4</span><br><span class="line">        _RayMarchDistance(&quot;步进距离 RayMarchDistance&quot;, Range(0.01, 1)) = 2.5</span><br><span class="line">        [IntRange] _RayMarchStep(&quot;步进步数 RayMarchStep&quot;, Range(1,128)) = 64</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        _SkyLineSize(&quot;天际线大小 SkyLineSize&quot;, Range(0, 1)) = 0.06</span><br><span class="line">        _SkyLineBasePow(&quot;天际线基础强度 SkyLineBasePow&quot;, Range(0, 1)) = 0.1</span><br><span class="line">        </span><br><span class="line">        _StarShinningSpeed (&quot;星星闪烁速度 StarShinningSpeed&quot;, Range(0, 1)) = 0.1</span><br><span class="line">        _StarCount(&quot;星星数量 StarCount&quot;, Range(0,1)) = 0.3</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Opaque&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        LOD 100</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fog</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldPos = mul(v.vertex, unity_ObjectToWorld);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float3 _AurorasColor;</span><br><span class="line">            float3 _SkyColor;</span><br><span class="line">            float _AurorasIntensity;</span><br><span class="line">            float _AurorasTiling;</span><br><span class="line">            float _AurorasSpeed;</span><br><span class="line">            float _AurorasAttenuation;</span><br><span class="line">            float _SkyCurvature;</span><br><span class="line">            float _RayMarchDistance;</span><br><span class="line">            float _RayMarchStep;</span><br><span class="line">            float _SkyLineSize;</span><br><span class="line">            float _SkyLineBasePow;</span><br><span class="line">            </span><br><span class="line">            float _StarShinningSpeed;</span><br><span class="line">            float _StarCount;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            sampler2D _AurorasNoiseTex;</span><br><span class="line">            sampler2D _StarNoiseTex;</span><br><span class="line">            float4 _StarNoiseTex_ST;</span><br><span class="line">            float4 _AurorasNoiseTex_ST;</span><br><span class="line">            </span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                tex2D(_StarNoiseTex, TRANSFORM_TEX(i.uv,_StarNoiseTex)).r;</span><br><span class="line">                </span><br><span class="line">                // 星星</span><br><span class="line">                float starColor = 0;</span><br><span class="line">                </span><br><span class="line">                const float starTime = _Time.y * _StarShinningSpeed;</span><br><span class="line"></span><br><span class="line">                // 计算叠加区间的两层星星UV</span><br><span class="line">                const float2 beginMove = floor(starTime) * 0.3;</span><br><span class="line">                const float2 endMove = ceil(starTime) * 0.3;</span><br><span class="line">                const float2 beginUV = i.uv + beginMove;</span><br><span class="line">                const float2 endUV = i.uv + endMove;</span><br><span class="line">                </span><br><span class="line">                // 采样两层星星的值</span><br><span class="line">                float beginNoise = tex2D(_StarNoiseTex, TRANSFORM_TEX(beginUV,_StarNoiseTex)).r;</span><br><span class="line">                float endNoise = tex2D(_StarNoiseTex, TRANSFORM_TEX(endUV,_StarNoiseTex)).r;</span><br><span class="line"></span><br><span class="line">                // 减少星星</span><br><span class="line">                beginNoise = saturate(beginNoise - (1 - _StarCount)) / _StarCount;</span><br><span class="line">                endNoise = saturate(endNoise - (1 - _StarCount)) / _StarCount;</span><br><span class="line"></span><br><span class="line">                const float fracStarTime = frac(starTime);</span><br><span class="line">                // 混合两层星星值</span><br><span class="line">                starColor = saturate(beginNoise - fracStarTime) + saturate(endNoise - (1 - fracStarTime));</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                // 计算ray march信息</span><br><span class="line">                // 每个像素发射射线</span><br><span class="line">                float3 rayOriginal = 0;</span><br><span class="line">                float3 totalDir = i.worldPos - rayOriginal;</span><br><span class="line">                float3 rayDir = normalize(totalDir);</span><br><span class="line">                //clip(rayDir.y);</span><br><span class="line"></span><br><span class="line">                // 拓展球面来计算march的起始点</span><br><span class="line">                // reciprocal 求倒数</span><br><span class="line">                // 天空曲率</span><br><span class="line">                float skyCurvatureFactor = rcp(rayDir.y + _SkyCurvature);</span><br><span class="line">                // 本质为模拟地球大气</span><br><span class="line">                // 无数条射线像外发射 就会形成一个球面 *天空曲率 就可以把它拍成一个球</span><br><span class="line">                float3 basicRayPlane = rayDir * skyCurvatureFactor * _AurorasTiling ;</span><br><span class="line">                // 从哪开始步进</span><br><span class="line">                float3 rayMarchBegin = rayOriginal + basicRayPlane;</span><br><span class="line"></span><br><span class="line">                // ray march</span><br><span class="line">                float3 color = 0;</span><br><span class="line">                float3 avgColor = 0;</span><br><span class="line">                // 一步的大小</span><br><span class="line">                float stepSize = rcp(_RayMarchStep);</span><br><span class="line">                </span><br><span class="line">                for (float i = 0; i &lt; _RayMarchStep; i += 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    float curStep = stepSize * i;</span><br><span class="line">                    // 初始的几次采样贡献更大, 我们用二次函数着重初始采样</span><br><span class="line">                    curStep = curStep * curStep;</span><br><span class="line">                    // 当前步进距离</span><br><span class="line">                    float curDistance = curStep * _RayMarchDistance;</span><br><span class="line">                    // 步进后的位置</span><br><span class="line">                    float3 curPos = rayMarchBegin + rayDir * curDistance * skyCurvatureFactor;</span><br><span class="line">                    float2 uv = float2(-curPos.x,curPos.z);</span><br><span class="line"></span><br><span class="line">                    // =====  极光动起来</span><br><span class="line">                    // 计算扰动uv</span><br><span class="line">          float2 warp_vec = </span><br><span class="line">                        tex2D(_AurorasNoiseTex,TRANSFORM_TEX((uv * 2 + _Time.y * _AurorasSpeed),_AurorasNoiseTex));</span><br><span class="line">                    // 采样当前的噪声强度</span><br><span class="line">                    float curNoise = tex2D(_MainTex, TRANSFORM_TEX((uv + warp_vec * 0.1), _MainTex)).r;</span><br><span class="line">                    //curNoise = tex2D(_MainTex, TRANSFORM_TEX(uv, _MainTex)).r;</span><br><span class="line">                    // =======================</span><br><span class="line">                    </span><br><span class="line">                    // 最后加强度衰减</span><br><span class="line">                    curNoise = curNoise * saturate(1 - pow(curDistance, 1 - _AurorasAttenuation));</span><br><span class="line">                    </span><br><span class="line">                    // 极光色彩累积计算</span><br><span class="line">                    // 由于sin的范围是-1到1，所以要先把颜色范围转换到-1到1之间，这通过i计算出当前步进层的色彩</span><br><span class="line">                    // 最后 * 0.5再加0.5就返回到了原本的0-1的范围区间</span><br><span class="line">                    float3 curColor = sin((_AurorasColor * 2 - 1) + i * 0.043) * 0.5 + 0.5;</span><br><span class="line">                    </span><br><span class="line">                    // 取两步色彩的平均值 使颜色更接近于本色 </span><br><span class="line">                    avgColor = (avgColor + curColor) / 2;</span><br><span class="line">                    </span><br><span class="line">                    // 混合颜色</span><br><span class="line">                    color += avgColor * curNoise * stepSize;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // 强度</span><br><span class="line">                color *= _AurorasIntensity;</span><br><span class="line"></span><br><span class="line">                // 混合天际线</span><br><span class="line">                color *= saturate(rayDir.y / _SkyLineSize + _SkyLineBasePow);</span><br><span class="line"></span><br><span class="line">                // 天空色</span><br><span class="line">                color += _SkyColor;</span><br><span class="line"></span><br><span class="line">                // 星星</span><br><span class="line">                color = color + starColor * 0.9;</span><br><span class="line">                </span><br><span class="line">                return fixed4(color, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>PBR</strong>是 <strong>Physically Based Rendering</strong>的简称，也就是图形渲染中的真实感渲染，简单理解就是基于物理的渲染技术，但它只是对现实世界物理的一种近似，并非完全的物理渲染，与之前学习的NPR属于完全不同的两种渲染理念，PBR是以基于<strong>微平面理论</strong>，<strong>能量守恒</strong>，以及物理的<strong>BRDF</strong>为核心的渲染理念。</p><p><strong>微平面理论</strong></p><p><img src="https://i0.hdslb.com/bfs/album/3f85f67f24bc35ef0b3c8ed7ab2155e904d95d3c.png" alt="img"></p><p>简单来说就是物体表面持续放大至微观尺度后，任何平面都是由 无数微小的无序随机朝向的镜面组成。</p><p>平面越是粗糙，这个平面上的微平面的排列就越混乱，平面越是光滑，光线大体上会更趋向于同一个方向反射，形成更小更锐利的反射。</p><p>其实在微观尺度下，没有任何平面是完全光滑的。但由于这些微平面已经微小到无法逐像素继续进行区分，因此会假设一个粗糙度参数，然后用统计学的方法来估算微平面的粗糙程度，通过这个粗糙度计算出某个向量的方向，与微平面平均取向的一致性。</p><p>一般粗糙度越高的显示出来的镜面反射的轮廓要更大一些，相反则会更小更锐利。在实际的PBR 中，这种物体表面的不规则性一般会用粗糙度贴图或者高光度贴图来表示~</p><p> -———————————————————————————————————— </p><p><strong>能量守恒</strong></p><p><img src="https://i0.hdslb.com/bfs/album/7c8052acfdc946907e07b2da1638de991aa244f1.png" alt="img"></p><p>说白了就是反射光的能量永远不能超过入射光的能量，为了遵守能量守恒定律，通常我们会对漫反射光和镜面反射光之间做出明确的区分。</p><p>在PBR中，镜面光指的就是光线射入物体表面时所反射的那部分能量，而漫反射光则是指光线进入物体后再均匀的发散出来的那部分能量。当光线碰撞到一个表面的时候，一部分能量被反射，另一部分能量进入物体内部。</p><p><img src="https://i0.hdslb.com/bfs/album/425869b3a9ccbc9e302d20ecd58e57f85db140c7.png" alt="img"></p><p>不过不同的材质表面它的反射细节也会有所不同，通常会分为金属和非金属材质，其中金属表面由于有自由电子，所以进入表面的能量会被完全吸收。而非金属表面由于没有自由电子，进入表面的能量有一部分会被均匀的释放出来，所以金属度低，但是完全光滑的物体，不会呈现金属那样的镜面效果，而是带有自身的颜色晕染。</p><p> -———————————————————————————————————— </p><p><strong>菲涅尔现象</strong></p><p>一般来说漫反射光和镜面反射光之间都是受菲涅尔参数所控制，通过菲涅尔我们可以根据观察的角度得到被反射的能量所占的百分比。利用这个反射比率和能量守恒原则，可以直接得出光线进入物体的部分以及光线剩余的能量。</p><p>菲涅尔表示的是看到的光线的反射率与视角相关的现象，视线垂直于表面时反射较弱，而当视线与表面夹角越小时，反射越明显。</p><p><img src="https://i0.hdslb.com/bfs/album/13b59c990da8097bc283ad6e469f331505e6a426.png" alt="img"></p><p>这就好比我们平时拿吸管插奶茶杯一样，物体的表面就可以看作是奶茶杯的那层膜，光线的光子可以看作是吸管，当你越是斜着插的时候 吸管就越容易被弹开 ， 很难插进去，而当你越是竖着插的时候，吸管也就越容易进去。这也就是所谓的菲涅尔现象。</p><p><img src="https://i0.hdslb.com/bfs/album/a1ee47f860f7b72521cb683297ba22d16a555491.png" alt="img"></p><p>而光线的能量进入物体之后会有不同的释放形式，对于金属表面来说，能量进去后，会全部吸收掉。</p><p><img src="https://i0.hdslb.com/bfs/album/5ac178306edfeddafa10caaf693efb7dbe1c61e0.png" alt="img"></p><p>而对于非金属表面来说，能量进去后，只会吸收一部分，余下的部分则会被释放。</p><p><img src="https://i0.hdslb.com/bfs/album/d8d73c66240cfda78104642642c98918a6257545.png" alt="img"></p><p>除此之外对于玉石这类 次表面 散射的 材质来说，能量进去后，会吸收一部分，而余下的能量会从正面出来一部分，从侧面也漏出来一部分。</p><p><img src="https://i0.hdslb.com/bfs/album/a760b46b128d1be1a47a72049b6f48365f8950eb.png" alt="img"></p><p>那对于玻璃这类透明的材质来说，能量进去后，吸收的部分很少，正面出来也很少，基本都会从另一面出来。</p><p> -———————————————————————————————————— </p><p><strong>真实感光照</strong></p><p><img src="https://i0.hdslb.com/bfs/album/024fd7550171c87736acd6bb26ebc32a4efff01b.png" alt="img"></p><p>PBR的光照不止是直接光，如果只是直接光，那PBR渲染出来的画面，其实和以前并没有多少明显的进步。通常我们会通过叠加计算直接光和间接光得到最终的光照结果，这个结果被称为全局光照，也就是常听到的GI。</p><p>说白点就是通过模拟光线的传播路径，将物体反射的间接光纳入计算，从而提高画面的真实感。直接光就是光线从光源直接照射到物体表面上的光，而间接光则是光线经过多次弹射到物体表面上的光。不过因为我们无法完全模拟现实中如此复杂的物理环境，像如阳光的大气折射与场景弹射次数和质量等，所以通常会加入环境光去做近似模拟。</p><p>这也是PBR中比较重要的光照部分 - IBL 也就是基于图像的光照。它会把周围的环境颜色完整的保存到一张贴图上，PBR材质会把这个贴图当作光源来进行采样，通过一系列的公式计算得到最终的环境光。如果是金属材质，并且粗糙度比较低，他就能够近乎完整的映射出周围的环境的镜像倒影。不过IBL不处理多次反射，它只是单纯的把环境贴图当成了光源的预积分，这里不做过多赘述，有个大致概念即可。</p><p> -———————————————————————————————————— </p><p><strong>BRDF</strong></p><p>学术一点的叫法就是双向反射分布函数，通过入射光方向，反射光方向，平面法线以及微平面粗糙程度作为函数的输入参数，求出最终反射光的强度。</p><p>其实我们之前做的Blinn-Phone也可以看作是一个BRDF，但由于Blinn-Phong并没有遵循能量守恒的定律，所以它不被认为是基于物理的渲染。</p><p>在早期 PBR模型包含了众多复杂的物理属性，学习成本高、不易于理解，后来在SIGGRAPH 2012，迪士尼提出了Disney BRDF <a href="https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf">s2012_pbs_disney_brdf_notes_v3.pdf (disneyanimation.com)</a> ，它把众多复杂的物理属性简化成更少更为直观的属性，以极高的易用性、便捷性正式进入了大众的视野，逐渐在业界内被广泛应用，可以说是PBR史上的里程碑。</p><p>Unity基于Disney BRDF的启发在GDC 2014 推出了Physically Based Shading in Unity <a href="https://aras-p.info/texts/files/201403-GDC_UnityPhysicallyBasedShading_notes.pdf">201403-GDC_UnityPhysicallyBasedShading.key (aras-p.info)</a> ，将传统的渲染工作流升级为基于物理的渲染工作流，美术同学只需要调节Unity内置的Standard Shader，就可以实现绝大多数常见的材质。</p><p>那关于BRDF这里我们不去剖析这些复杂的公式，只对它最终的参数进行了解即可~</p><p><img src="https://i0.hdslb.com/bfs/album/72cde93878faa4af40cff51e975b39c79657b18d.png" alt="img"></p><p>那最终Disney BRDF得到了1个颜色参数以及10个标量参数，颜色参数就是 <strong>BaseColor</strong> 表面颜色，通常由纹理贴图提供</p><p><strong>Subsurface</strong>：使用 次表面近似 控制 漫反射的形状</p><p><strong>Metallic</strong>：金属与非金属两种不同模型之间的线性混合。金属模型没有漫反射的成分</p><p><strong>Specular</strong>：一般用来控制镜面反射的强度</p><p><strong>SpecularTint</strong>：镜面反射的颜色啦，不过这个相对过时，通常很少有对美术控制的让步，一般会用于对基础色的入射镜面反射，进行颜色的控制。</p><p><strong>Roughness</strong>：用来控制表面的粗糙度啦</p><p><strong>Anisotropic</strong>：各向异性的强度，主要用于头发啊金属之类的材质</p><p><strong>Sheen &amp; SheenTint</strong>：控制的是光泽的强度和颜色，一般会用于布料</p><p><strong>Clearcoat &amp; ClearcoatGloss:</strong> 则是清漆强度和光泽度，平时用到的很少，知道有这么个东西就好啦</p><p> -—————————————————————————-</p><p><strong>Standard Shader</strong></p><p><img src="https://i0.hdslb.com/bfs/album/337c2c22c0d478a1fc6b9ae7aa765e38223dda17.png" alt="img"></p><p><strong>RenderingMode</strong>：控制的是物体的渲染模式，简单理解就是设定物体是透明的渲染模式还是不透明的渲染模式</p><p><strong>Albedo</strong>：其实就是材质的基础固有色，你可以给它一张纹理贴图也可以选择单色，当你选择纹理贴图的时候这个调色板则为纹理之上的叠加色</p><p><strong>Metallic &amp; Smoothness</strong>：这里则是用来控制材质的金属度和光滑度，金属度只是决定了物体最终渲染的结果是以高光为主，还是漫反射为主。而光滑度则是决定了物体的高光部分是否清晰。通常来说不使用贴图的话材质只能具有单一的金属度，这并不理想，毕竟同一个物体表面 可能会具有不同的表面特性，那这里如果你选择了金属度贴图，这里的滑动条会直接隐藏掉，通过贴图所存储的 金属度信息来进行采样计算。光滑度的概念其实和我们之前所提的的粗糙度大同小异，反过来了而已。</p><p><strong>Source</strong>：可以理解为就是选择光滑贴图，它的数据可以来源于金属贴图，也可以是色彩贴图，这就根据美术来定啦~</p><p><strong>NormalMap</strong>：法线贴图，它属于凹凸贴图的一种，通常用来给模型增加一些微小的凸起、凹槽和划痕等细节，在逐像素计算光照时，每个像素都会根据该点的法向量来计算最终该点的光照结果，可以通过法线贴图，改变这个点法线方向，影响它的光照结果，进而影响模型表面凹凸感。</p><p><strong>HeightMap</strong>：视差贴图，又可以称之为高度贴图，是法线贴图的改进版，属于一个经常被忽略的高级功能。大家都知道法线，可以将一个平面做成凹凸不平的效果，但是当视角方向水平于该平面的时候，理论上凸起的部分会遮挡住后面的部分，而法线贴图却没有这个效果，但是高度贴图，就可以。那原理呢，就是根据该点的高度以及该点指向摄像机的向量，计算出一个UV偏移，来影响之后的采样。</p><p><strong>Occlusion</strong>：环境光遮蔽贴图，通常又会叫AO贴图，在PBR中计算光照的时候，一般直接通过采样IBL来得到环境光，这个环境光是该点上一个半球上的积分。但是因为自身的之间会有凹凸，在凹陷的地方，环境光会被周围给遮挡，所以看起来并不是那么亮，通过AO贴图我们可以让调整环境光的大小，从而达到更真实的效果。</p><p><strong>Emission</strong>：材质的自发光属性，通常用于控制从表面发出的光的颜色和强度，用的比较多的地方像如霓虹灯、LED屏幕等等。</p><p><strong>Tiling &amp; Offset</strong>：控制的则是以上所有贴图的Tiling Offset</p><h2 id="URP与HDRP"><a href="#URP与HDRP" class="headerlink" title="URP与HDRP"></a>URP与HDRP</h2><h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h3><p>Unity的渲染管线大致可分2大类，内置渲染管线 Built-in以及可编程渲染管线SRP，之前的内容所接触到的全都是内置的渲染管线。</p><p><strong>Built-in 内置渲染管线</strong></p><p><img src="https://i0.hdslb.com/bfs/album/496582c5be3f89dc24bc781fe1b4855d21819630.png" alt="img"></p><p>它的渲染流程实现，全部都是写在引擎源码里的。而大部分开发者是不会去修改源码的，那这基本上算是不能改动，所以过去的渲染管线对开发者来说，是很难进行定制开发的。而内置渲染管线在一个管线里面支持了所有的二十多个平台，高端的PC支持，很老的手机也要支持，这就应了周星驰电影里的那句我全都要，结果就导致代码越来越臃肿，很难使性能和效果做到最好。</p><p><strong>Scriptable Render Pipeline 可编程渲染管线</strong></p><p><img src="https://i0.hdslb.com/bfs/album/52af92c2d36e737e566bb3d43edf9f4c6cc21682.png" alt="img"></p><p>为了解决原本的内置渲染管线不够灵活的这一问题，Unity在2018之后提供了新的渲染系统 - SRP，全称就是Scriptable Render Pipeline </p><p>它可以在Unity里通过C#脚本调用一系列的API配置和执行渲染命令 ， 来实现一套自定义的渲染流程，你可以根据自己的需求来调整流程或着修改功能。相当于就是帮我们在复杂的底层图形API基础之上，封装了一套通俗易懂的C#API，本质上最后调用的还是底层的图形API。那所谓的图形API就是我们之前提到的像如OpenGL、Direct3D这类的底层渲染API层。</p><p>其实SRP简单理解就像是我们的汽车产业，把所有东西都定死的成品车，拆成了各式各样的零部件，让你根据自己的需求来组装。但这就又产生了另一个问题，SRP只丢给了我们一堆散装的零件，而这个拼装过程又非常复杂，很少有人能知晓整个拼装流程。这需要开发者对底层的渲染流程和图形API有足够的认知才可以实现。无疑是增加了开发者的入门门槛，即使费了好大劲组装起来，安全上也无法保证。</p><p><strong>URP &amp; HDRP</strong></p><p><img src="https://i0.hdslb.com/bfs/album/beff95dbf6ec7999ffb58f316eb8832624c17eb0.png" alt="img"></p><p>为了解决这一问题，Unity给我们提供了两个可以直接上路的解决方案URP 和 HDRP。他们都是在SRP的API基础之上构建的渲染管线 解决方案，你可以直接开车上路也可以根据自己的需求换个轮胎或者改个内饰。</p><p>其中URP 全称是Universal Render Pipeline 通用渲染管线，早期被称为LWRP Lightweight RP 也就是轻量级渲染管线, 在2019.3开始改名为URP，它涵盖了范围广泛的不同平台，是针对跨平台开发而构建的，性能和画质都要比内置管线好，另外还可以进行自定义，实现不同风格的渲染，那这也是目前最推荐大家使用的渲染管线。</p><p>而HDRP（High-Definition Render Pipeline）高清渲染管线，则是针对高端设备下的高真实感图形和渲染，像如如 PC、Xbox 和 PlayStation 等高端硬件。</p><p>这就像不同的汽车品牌一样，URP就好比专注大众消费的TOYOTA，而HDRP则是为高端精英人士准备的梅赛德斯奔驰。</p><p>那除此之外我们还可以在Unity的官方文档看到他们之间详细的对比，像如它们所支持的平台呀光照呀相机等相关得到信息，你都可以轻松的在这里找到想要的答案。</p><h3 id="实战案例-Built-in-升级HDRP"><a href="#实战案例-Built-in-升级HDRP" class="headerlink" title="实战案例 - Built-in 升级HDRP"></a>实战案例 - Built-in 升级HDRP</h3><p>在Window下打开Package Manager，选择Unity Registry, </p><p><img src="https://i0.hdslb.com/bfs/album/f8cc18b3f73c4b2fad5b9132c581a8b292edd993.png" alt="img"></p><p>找到HDRRP Package，点击安装就可以啦，</p><p><img src="https://i0.hdslb.com/bfs/album/765ab282188f88122bc00c8f46befa62bbcb9f66.png" alt="img"></p><p>然后打开Window&gt;Rendering&gt;HDRP Wizard窗口</p><p><img src="https://i0.hdslb.com/bfs/album/525fe9c38616ed8ca4dfd60618f7a333da7e8017.png" alt="img"></p><p>点击FixAll，Unity则会自动修复HDRP相关的Error</p><p><img src="https://i0.hdslb.com/bfs/album/4d8eecc5fba8ec15c62f56961d617e2893f8ef13.png" alt="img"></p><p>修复完成后会弹出一个框，选择CreateOne，创建HDRP Asset资源</p><p><img src="https://i0.hdslb.com/bfs/album/614464b4c0395e85b91753d605fb34d06c712877.png" alt="img"></p><p>那现在场景中的材质依然是101品红色，这是因为Shader还是用的内置渲染管线的Shader，</p><p><img src="https://i0.hdslb.com/bfs/album/9207435a87c8afa547b300cfc8f94b2400372b91.png" alt="img"></p><p>所以，这里点击HDRP Wizard窗口下面这栏的第一个按钮，将项目中的所有不兼容材质转换为 HDRP 材质，</p><p><img src="https://i0.hdslb.com/bfs/album/ab561d7a89c900e245c6368e0b79635ef7e7b446.png" alt="img"></p><p>转换完成后，将Sky Fog Volume添加到场景里用来设置环境照明，</p><p><img src="https://i0.hdslb.com/bfs/album/80efadbc66827aeff7af03fa36474ac4a9748cde.png" alt="img"></p><p>打开Window &gt; Rendering &gt; Lighting，选择刚刚Volume的配置文件</p><p><img src="https://i0.hdslb.com/bfs/album/63cae2bd5618768c94a850e244aa0fa3d140b0dc.png" alt="img"></p><p>下面这个静态光照天空属性，选择PhysicallyBasedSky，</p><p><img src="https://i0.hdslb.com/bfs/album/259fee015f88fcbb4110c80c1b0197764bdec7b3.png" alt="img"></p><p>调节一下光照色温</p><p><img src="https://i0.hdslb.com/bfs/album/3aa5d77c69ad0c17e4c4510cb3ba239d71491250.png" alt="img"></p><p>那简单的HDRP升级就完成啦，是不是一下就比原来细致了许多呢</p><p><img src="https://i0.hdslb.com/bfs/album/5287dfa5cd4aaf9d07c4f24421763d98153fe913.png" alt="img"></p><h3 id="实战案例-Built-in-升级URP"><a href="#实战案例-Built-in-升级URP" class="headerlink" title="实战案例 - Built-in 升级URP"></a>实战案例 - Built-in 升级URP</h3><p>在Window下打开Package Manager，选择Unity Registry,</p><p><img src="https://i0.hdslb.com/bfs/album/f4bea6dfd53c6426a01ed36964f0cd748ce115bb.png" alt="img"></p><p>找到URP Package，点击安装就可以啦，不过安装了并不代表我们现在用的就是URP管线，</p><p><img src="https://i0.hdslb.com/bfs/album/1423eed59dfdbdbfd5392edd730334efb47f4b12.png" alt="img"></p><p>需要在Assets目录下点击Create&gt;Rendering&gt;URP Asset，给它改个名字，创建完成后，</p><p><img src="https://i0.hdslb.com/bfs/album/4203b360ee03345c844a03676906576b82bf802c.png" alt="img"></p><p>点击Editor&gt;Project Settings&gt;Graphics&gt;Scriptable Render Pipeline Settings，选择刚刚创建好的URPAsset</p><p><img src="https://i0.hdslb.com/bfs/album/ca8e45d83543137922b9033b3959b07be44d722e.png" alt="img"></p><p>然后会弹出一个对话框，点击Continue</p><p><img src="https://i0.hdslb.com/bfs/album/41b6941993f9a4c097fdfa5ece9a1de42f4cd6fb.png" alt="img"></p><p>我们发现设置完成后场景中的材质变成了我们之前所说的101色，那不要担心，接下来在Window&gt;Rendering&gt;Render Pipeline Converter 打开转换器</p><p><img src="https://i0.hdslb.com/bfs/album/75ddeaab742c02eb1153523caeae0e8c637306d2.png" alt="img"></p><p>打开后选择Built-in to URP，然后选择要转换的内容</p><p><img src="https://i0.hdslb.com/bfs/album/107165e09ef81494c22ed26c60204fd86b861f53.png" alt="img"></p><p>勾选完成之后点击左下角按钮进行转换 初始化设置</p><p><img src="https://i0.hdslb.com/bfs/album/1d1b61f03d0787c1f3d309593edccc316ac97248.png" alt="img"></p><p>初始化完成之后点击 右下角按钮 进行资产转换，就可以啦</p><p><img src="https://i0.hdslb.com/bfs/album/936c8dbb77e6eda36cf22c351d54103b59d723f4.png" alt="img"></p><p>细心的小伙伴可能发现之前做的轮廓线不见了，通过官方的文档 <a href="https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/urp-shaders/urp-shaderlab-pass-tags.html">URP ShaderLab Pass 标签 | Universal RP | 12.1.1 (unity3d.com)</a> 可以看到，由于在URP里新增了特定的Pass tag，需要给Pass添加特定的Tag LightMode才可以进行多pass渲染</p><p>但其实URP 本身的设计思想并不鼓励在shader里写多pass，而是利用 Render feature 实现各种功能，那既然轮廓线只用到了两个pass，所以就简单的给pass加一下tag就好啦，</p><p>正常的渲染就用UniversalForward即可，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              Pass</span><br><span class="line">&#123;</span><br><span class="line">                  Tags</span><br><span class="line">                  &#123;</span><br><span class="line">                         &quot;LightMode&quot; = &quot;UniversalForward&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><p>像如描边这种需要在渲染对象时绘制额外的 Pass，这里就可以选择SRPDefaultUnlit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              Pass</span><br><span class="line">&#123;</span><br><span class="line">                  Tags</span><br><span class="line">                  &#123;</span><br><span class="line">                         &quot;LightMode&quot; = &quot;SRPDefaultUnlit&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><h3 id="实战案例-简单URP水面效果"><a href="#实战案例-简单URP水面效果" class="headerlink" title="实战案例 - 简单URP水面效果"></a>实战案例 - 简单URP水面效果</h3><p>URP除了对管线的升级外，ShaderLab也从原来的CG升级到了HLSL，虽说有向前兼容，原来的CG也不是不能用，但在升级管线之后，Unity SRP 使用的都是HLSL 语言，继续使用CG容易出现许多不知所以的问题。而且URP在ShaderLibrary里面还提供了许多好用的API库</p><p><img src="https://i0.hdslb.com/bfs/album/282c260b16b773ff03add7e336091865c1229758.png" alt="img"></p><p>那这里通过简单的水面效果来熟悉一下新的HLSL吧~ 其实它与之前的CG大体上还是差不多的，首先新建一个Unlit Shader，把CGPROGRAM替换成HLSLPROGRAM，下面的End也记得换一下</p><p><img src="https://i0.hdslb.com/bfs/album/d9a747987176e172d6ad27032e35dad5fc5bccc8.png" alt="img"></p><p>把渲染管线标记为URP，由于是水面效果，水是透明的，所以渲染类型也要改成透明，同样把它的渲染队列也标注为透明，最后给它加个透明度混合即可。</p><p><img src="https://i0.hdslb.com/bfs/album/5db0df180c98359620e8311df767ad20794aabf7.png" alt="img"></p><p>通常来说水深不同水面的颜色也就不同，因为水分子会吸收通过它的  光的能量，所以这里给它添加两个属性，一个深水色，一个浅水色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_ShallowWater (&quot;shallowColor&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">_DeepWater (&quot;DeepColor&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br></pre></td></tr></table></figure><p>那如何得知水的深浅呢？这里则需要通过拿到场景的深度信息来计算水面的深度，在以往这是一个比较麻烦的步骤，而现在Unity给我们提供了许多好用的函数库，其中有一个就是深度相关的，这里我们直接给它include进来，把之前的CG库替换掉，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;</span><br></pre></td></tr></table></figure><p>看到下面的代码报错不要慌，这里fixed给它改成half就可以啦，由于fixed精度过于低，所以hlsl干脆给它丢掉了，当然想要更高的精度也可以使用float。</p><p><img src="https://i0.hdslb.com/bfs/album/d67706c2ad78677006d4be31197c26dcdf05e3c5.png" alt="img"></p><p>函数报错呢也是因为更新了核心库，所以相关的API也变了</p><p><img src="https://i0.hdslb.com/bfs/album/aee3687b8957ce31618a3d548a2f5e8e55eb09d4.png" alt="img"></p><p>那我们该怎么找呢，有点一头雾水。打开ShaderLibary里的核心库</p><p><img src="https://i0.hdslb.com/bfs/album/f69cb3ed2edbeddc121e7189d1c3594ad0783f7f.png" alt="img"></p><p>搜索关键字，跳转着看看一般就可以找到了，你会发现所有的顶点位置信息都合并到了这一个结构体里啦，</p><p><img src="https://i0.hdslb.com/bfs/album/c62072ef61e310e465d590b053fe9b3721d315d8.png" alt="img"></p><p> 声明并且通过get给它初始化一下，这样我们的数据就全都拿好啦，是不是比之前的要方便许多呢，把之前报错的API删掉就可以啦，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VertexPositionInputs positionInputs = GetVertexPositionInputs(v.positionOS);</span><br></pre></td></tr></table></figure><p>那深度纹理是全屏纹理，它和屏幕的尺寸相同。而我们希望在当前像素相同的位置对深度进行采样。所以，这里需要要把顶点在屏幕空间位置算好，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    VertexPositionInputs positionInputs = GetVertexPositionInputs(v.positionOS);</span><br><span class="line">    o.positionCS = positionInputs.positionCS;</span><br><span class="line">    o.screenPosition = ComputeScreenPos(positionInputs.positionCS);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引入的库函数来获取屏幕深度，然后把这个深度转换到视图空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    // 通过深度纹理的采样 计算屏幕深度</span><br><span class="line">    float sceneRawDepth = SampleSceneDepth(i.screenPosition.xy / i.screenPosition.w);</span><br><span class="line">    // 深度纹理的采样结果转换到视图空间下的深度值</span><br><span class="line">    float sceneEyeDepth = LinearEyeDepth(sceneRawDepth, _ZBufferParams);</span><br><span class="line">    return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于关心的是这个深度值相对于水面有多深，所以需要把视图深度,减去模型顶点的深度，得到最终水的深度，然后把刚刚的  深浅水颜色 根据水的深度做个lerp，就可以啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 最终得到水的深度</span><br><span class="line">float waterDepth = sceneEyeDepth - i.screenPosition.w; </span><br><span class="line">// 拿到水的颜色</span><br><span class="line">float3 waterColor = lerp(_ShallowWater, _DeepWater, waterDepth);</span><br></pre></td></tr></table></figure><p>为了使水多少有点流动感，这里通过noise给它做个简单的漂浮扰动效果，为了让它有流动效果所以给它加个时间和速度进行采样，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float surfaceNoiseSample = tex2D(_SurfaceNoise, i.noiseUV + _Time.y * _MoveSpeed * 0.1).r;</span><br></pre></td></tr></table></figure><p>然后根据深度加一圈浮沫，和刚刚的波动混合一下，最后把水的颜色和浮沫的颜色叠加一下，把透明度公开出来，就大功告成啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 浮沫</span><br><span class="line">float foam = saturate(waterDepth / _FoamDistance);</span><br><span class="line">float surfaceNoise = smoothstep(0, foam, surfaceNoiseSample) ;</span><br><span class="line">// 混合水面透明度</span><br><span class="line">float4 col = float4(waterColor + surfaceNoise * _FoamColor, _WaterAlpha) ;</span><br><span class="line">return col;</span><br></pre></td></tr></table></figure><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;URP/Water&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _ShallowWater (&quot;shallowColor&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">        _DeepWater (&quot;DeepColor&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">        _WaterAlpha(&quot;WaterAlpha&quot;,Range(0,1)) = 0.5</span><br><span class="line">        </span><br><span class="line">        _SurfaceNoise(&quot;Surface Noise&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _MoveSpeed(&quot;MoveSpeed&quot;,Range(0,1)) = 0.5</span><br><span class="line">        </span><br><span class="line">        _FoamDistance(&quot;Foam Distance&quot;,Range(0,10)) = 0.4</span><br><span class="line">        _FoamColor(&quot;FoamColor&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;RenderPipeline&quot;=&quot;UniversalPipeline&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            </span><br><span class="line">            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;</span><br><span class="line">            </span><br><span class="line">            float4 _ShallowWater;</span><br><span class="line">            float4 _DeepWater;</span><br><span class="line">            float _WaterAlpha;</span><br><span class="line"></span><br><span class="line">            sampler2D _SurfaceNoise;</span><br><span class="line">            float4 _SurfaceNoise_ST;</span><br><span class="line">            float _MoveSpeed;</span><br><span class="line">            </span><br><span class="line">            float _FoamDistance;</span><br><span class="line">            float4 _FoamColor;</span><br><span class="line"></span><br><span class="line">            // 顶点着色器的输入</span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float3 positionOS : POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            // 顶点着色器的输出</span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 positionCS : SV_POSITION;</span><br><span class="line">                float4 screenPosition : TEXCOORD0;</span><br><span class="line">                float2 noiseUV : TEXCOORD1;</span><br><span class="line">                float2 distortUV : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                VertexPositionInputs positionInputs = GetVertexPositionInputs(v.positionOS);</span><br><span class="line">                o.positionCS = positionInputs.positionCS;</span><br><span class="line">                o.noiseUV = TRANSFORM_TEX(v.uv, _SurfaceNoise);</span><br><span class="line">                o.screenPosition = ComputeScreenPos(positionInputs.positionCS);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            half4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // 通过深度纹理的采样 计算屏幕深度</span><br><span class="line">                float sceneRawDepth = SampleSceneDepth(i.screenPosition.xy / i.screenPosition.w);</span><br><span class="line">                // 深度纹理的采样结果转换到视图空间下的深度值</span><br><span class="line">                float sceneEyeDepth = LinearEyeDepth(sceneRawDepth, _ZBufferParams);</span><br><span class="line">                // 因为关心的是这个深度值相对于我们的水面有多深，所以需要把视图深度,减去模型顶点的深度</span><br><span class="line">                // 最终得到水的深度</span><br><span class="line">                float waterDepth = sceneEyeDepth - i.screenPosition.w; </span><br><span class="line">                // 拿到水的颜色</span><br><span class="line">                float3 waterColor = lerp(_ShallowWater, _DeepWater, waterDepth);</span><br><span class="line">                </span><br><span class="line">                float surfaceNoiseSample = tex2D(_SurfaceNoise, i.noiseUV + _Time.y * _MoveSpeed * 0.1).r;</span><br><span class="line">                </span><br><span class="line">                // 浮沫</span><br><span class="line">                float foam = saturate(waterDepth / _FoamDistance);</span><br><span class="line">                float surfaceNoise = smoothstep(0, foam, surfaceNoiseSample) ;</span><br><span class="line">                // 混合水面透明度</span><br><span class="line">                float4 col = float4(waterColor + surfaceNoise * _FoamColor, _WaterAlpha) ;</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ShaderGraph"><a href="#ShaderGraph" class="headerlink" title="ShaderGraph"></a>ShaderGraph</h2><p><img src="https://i0.hdslb.com/bfs/album/2e8bb8b98238aa36539fb0ca43f3c6be92670aaf.png" alt="image-20220915202358287"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏游戏相关素材网站</title>
      <link href="/2023/01/05/Unity/%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99/"/>
      <url>/2023/01/05/Unity/%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏相关素材网站"><a href="#游戏相关素材网站" class="headerlink" title="游戏相关素材网站"></a>游戏相关素材网站</h1><span id="more"></span><p>视频链接</p><p><a href="https://www.bilibili.com/video/BV1cp4y1r7Rk?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1cp4y1r7Rk?spm_id_from=333.999.0.0</a></p><p>经典游戏素材\1. Spriters Resource</p><p>&gt;&gt;spriters-resource.com</p><p>\2. OpenGameArt找素材或灵感<br>&gt;&gt;<a href="https://opengameart.org/">https://opengameart.org/</a></p><p>\3. Pinterest找灵感<br>&gt;&gt;pinterest.com<br>\4. Piskel<br>&gt;&gt;<a href="https://www.piskelapp.com/">https://www.piskelapp.com/</a>  2D像素绘画</p><p>\5. Iconfont.cn<br>&gt;&gt;<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a><br>\6. Photopea<br>&gt;&gt;<a href="https://www.freephotoeditor.net/">https://www.freephotoeditor.net/</a><br>\7. Google Poly<br>&gt;&gt;<a href="https://poly.google.com/">https://poly.google.com/</a><br>\8. Blender<br>\9. TinkerCAD<br>&gt;&gt;<a href="https://www.tinkercad.com/">https://www.tinkercad.com/</a><br>\10. Mixamo<br>&gt;&gt;<a href="https://www.mixamo.com/">https://www.mixamo.com/</a><br>\11. SFXR<br>\12. ColorPix<br>&gt;&gt;<a href="https://pan.baidu.com/s/1xHh7PQYcOocXve5dOqFoSA">https://pan.baidu.com/s/1xHh7PQYcOocXve5dOqFoSA</a> 提取码: 1x2t<br>\13. CC0 Texture<br>&gt;&gt;<a href="https://cc0textures.com/">https://cc0textures.com/</a></p><p>推荐3个音频素材网站，都是完全免费而且可以商用的。<br><a href="https://zh-cn.soundeffect-lab.info/">https://zh-cn.soundeffect-lab.info/</a><br><a href="https://taira-komori.jpn.org/freesoundcn.html">https://taira-komori.jpn.org/freesoundcn.html</a><br><a href="https://maoudamashii.jokersounds.com/">https://maoudamashii.jokersounds.com/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity剧情编辑插件——Fungus</title>
      <link href="/2023/01/05/Unity/Unity%E5%89%A7%E6%83%85%E7%BC%96%E8%BE%91/"/>
      <url>/2023/01/05/Unity/Unity%E5%89%A7%E6%83%85%E7%BC%96%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity剧情编辑插件——Fungus介绍"><a href="#Unity剧情编辑插件——Fungus介绍" class="headerlink" title="Unity剧情编辑插件——Fungus介绍"></a>Unity剧情编辑插件——Fungus介绍</h1><span id="more"></span><h2 id="Fungus"><a href="#Fungus" class="headerlink" title="Fungus"></a>Fungus</h2><p>下载链接：<a href="https://github.com/snozbot/fungus">https://github.com/snozbot/fungus</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="https://i0.hdslb.com/bfs/album/791bbb31f61a7a64ab9c05e87a40089359545dee.png" alt="image-20220719184451199"></p><p>先创建一个flowchart</p><p><img src="https://i0.hdslb.com/bfs/album/eb860cbc56da2045aaa8a7802c5349a5bef805eb.png" alt="image-20220719184545618"></p><p>选中节点之后，右边可以设置属性。</p><p><img src="https://i0.hdslb.com/bfs/album/5649316478bd0137f2bdc8c51159a5715278316e.png" alt="image-20220719184840709"></p><p>勾选这个，可以选择颜色。</p><p>用不同的颜色来区分不同的节点。</p><p><img src="https://i0.hdslb.com/bfs/album/10e7c2df00d497825ae7377787488160848c92dc.png" alt="image-20220719184957585"></p><p>对话系统开始的时间</p><p><img src="https://i0.hdslb.com/bfs/album/30a7c969d034db1909315524023b0dc3fc0a2269.png" alt="image-20220719185110868"></p><p>点加号，添加一个事件。</p><p>搜索say。</p><p><img src="https://i0.hdslb.com/bfs/album/937a08204c3b1fd8cd15a6ce9476cbc09f15b6fa.png" alt="image-20220719185147174"></p><p>输入说的内容。</p><p><img src="https://i0.hdslb.com/bfs/album/d74736b29cfafb838920751180e173b88e1f294c.png" alt="image-20220719185257375"></p><p>创建一个说话的角色。</p><p><img src="https://i0.hdslb.com/bfs/album/26c0bf1dee2587505a2aa2a7197303d4db08100f.png" alt="image-20220719185451819"></p><p>可以添加说话的图像。</p><p><img src="https://i0.hdslb.com/bfs/album/c9fa4ea6694fd172f00f9b416dc3a7813aaf0403.png" alt="image-20220719185617862"></p><p>在事件这里选说话的对象。</p><p><img src="https://i0.hdslb.com/bfs/album/c9bf2481360c62d8edb63f87de9d65f5caa0df19.png" alt="image-20220719185757710"></p><p>可以给标签添加效果。</p><p><img src="https://i0.hdslb.com/bfs/album/d0fa8cfe33e0f00cb153199ddc4edccb3a2bc8a8.png" alt="image-20220719193049112"></p><p>创建menu事件让玩家选择。</p><p><img src="https://i0.hdslb.com/bfs/album/cab3539ff28b1df3ec4c6b4e66d949487d75fea1.png" alt="image-20220719193505752"></p><p>记得选对应的目标节点。</p><p><img src="https://i0.hdslb.com/bfs/album/67e41edccf388274d8f3cd1dfeaf5a1ab3fe5226.png" alt="image-20220719193757167"></p><p>没有menu，想跳转节点的话，可以使用Scene&#x2F;Message Received</p><p><img src="https://i0.hdslb.com/bfs/album/6989e3931b951eb1bd299a47d3ffb3669a971fd2.png" alt="image-20220719194007402"></p><p>在上一个节点创建send message事件。</p><p><img src="https://i0.hdslb.com/bfs/album/5870c6ad61ec0e80ac4d84f71d92c24e1f83c406.png" alt="image-20220719194058810"></p><p>message和刚才保持一至。</p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p><img src="https://i0.hdslb.com/bfs/album/d8c48b8a0263f107ddc22bde9c7f069061633562.png" alt="image-20220719194233716"></p><p>可以创建自定义对话框。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><img src="https://i0.hdslb.com/bfs/album/2dccf807df450f1ceadf0e0a91132d585e75e317.png" alt="image-20220719194559170"></p><p>新建空对象，加上Playable Director组件。</p><p>创建几个timeline。</p><p><img src="https://i0.hdslb.com/bfs/album/2888d7c0ee7abbe556240cfa6ef096353fb581ac.png" alt="image-20220719194919697"></p><p>把timeline拖过来。</p><p><img src="https://i0.hdslb.com/bfs/album/929cdffb13a88e95317f022ae9a4aaa94b40c54a.png" alt="image-20220719195020147"></p><p>选中人物模型，拖拽到timeline上。</p><p><img src="https://i0.hdslb.com/bfs/album/32a211056f1ced2bd5212f6e6ec2cbac27ac0080.png" alt="image-20220719195206255"></p><p>可以添加动画片段。</p><p><img src="https://i0.hdslb.com/bfs/album/a054bc4ccba308bad790b2df554472a108e5e6b0.png" alt="image-20220719200232384"></p><p>不同的片段可以重合在一起，自动生成过渡效果。</p><p><img src="https://i0.hdslb.com/bfs/album/7bb9096eb231c79e14de8a9d15a894caf0f0f93e.png" alt="image-20220719200656766"></p><p>可以添加变量控制动画。</p><p><img src="https://i0.hdslb.com/bfs/album/bcc0e09018551779782b9c6222e526729b88c7ea.png" alt="image-20220719200909750"></p><p>然后在剧情控制这里设置变量。</p><p>给动画控制器加个脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using Fungus;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Playables;</span><br><span class="line">using UnityEngine.Timeline;</span><br><span class="line">public class Controller : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public PlayableDirector animationController;</span><br><span class="line">    public TimelineAsset[] timelines;</span><br><span class="line">    public string[] timelineNames;</span><br><span class="line">    public Flowchart flowchart;</span><br><span class="line">    </span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; timelines.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (flowchart.GetBooleanVariable(timelineNames[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                animationController.Play(timelines[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            flowchart.SetBooleanVariable(timelineNames[i],false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/2023/01/05/index/"/>
      <url>/2023/01/05/index/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my Blog.<br>Here you could find some knowledge and my thought about Unity, UE and other areas.<br>Wish you will find what you need here!<br>Enjoy Yourselves!</p>]]></content>
      
      
      
        <tags>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Obsidian 使用技巧</title>
      <link href="/2023/01/04/%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%B0%8F%E6%8A%80%E5%B7%A7/Obsidian%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/01/04/%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%B0%8F%E6%8A%80%E5%B7%A7/Obsidian%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Obsidian 使用技巧</p><span id="more"></span><p><a href="https://blog.csdn.net/NSJim/article/details/109045914?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-109045914-blog-82826664.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-109045914-blog-82826664.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=2">LaTeX数学公式-详细教程_NSJim的博客-CSDN博客_latex 数学</a><br><a href="https://publish.obsidian.md/chinesehelp/01+2021%E6%96%B0%E6%95%99%E7%A8%8B/2021%E5%B9%B4%E6%96%B0%E6%95%99%E7%A8%8B">2021年新教程 - Obsidian中文教程 - Obsidian Publish</a><br><a href="https://zhuanlan.zhihu.com/p/428519519">想一小时上手obsidian？这一篇就够了。【玩转Obsidian的保姆级教程】 - 知乎 (zhihu.com)</a><br><a href="https://cloud.tencent.com/developer/article/1952241">安装插件</a><br>ctrl+E切换编辑模式和视图模式<br><img src="https://i0.hdslb.com/bfs/album/dbe0489f20dcc873d5a2fe027ef093f9e4b2409e.png"></p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>共可分6级。<br>1级标题：**#**+<strong>空格</strong>+<strong>标题</strong>  </p><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><p>2级标题：**##<strong>+<strong>空格</strong>+<strong>标题</strong><br>3级标题：</strong>###<strong>+<strong>空格</strong>+<strong>标题</strong><br>4级标题：</strong>####<strong>+<strong>空格</strong>+<strong>标题</strong><br>5级标题：</strong>#####<strong>+<strong>空格</strong>+<strong>标题</strong><br>6级标题：</strong>######**+<strong>空格</strong>+<strong>标题</strong></p><h3 id="2-分割线"><a href="#2-分割线" class="headerlink" title="2. 分割线"></a>2. 分割线</h3><p>连续输入≥3个的 <strong>-</strong> 或 *****</p><hr><hr><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h3><ul><li>无序列表：文本开头使用 *****+<strong>空格</strong>，或者**-**+<strong>空格</strong></li><li>有序列表：文本开头使用 <strong>数字</strong>+<strong>.</strong>+<strong>空格</strong></li></ul><p>* </p><p>1. </p><h3 id="4-插入外部链接"><a href="#4-插入外部链接" class="headerlink" title="4. 插入外部链接"></a><strong>4. 插入外部链接</strong></h3><ul><li>以地址方式显示：直接粘贴</li><li>以描述显示：**<a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">描述</a>** 快捷键 Ctrl+K</li><li></li><li></li></ul><h3 id="5-块引用"><a href="#5-块引用" class="headerlink" title="5. 块引用"></a><strong>5. 块引用</strong></h3><p>段落开头使用 <strong>&gt;</strong></p><blockquote><p>这是块引用</p></blockquote><h3 id="6-代码"><a href="#6-代码" class="headerlink" title="6. 代码"></a><strong>6. 代码</strong></h3><ul><li>整段代码：段落开头输入一个<strong>制表符</strong>(Tab)</li><li>段落文本中的代码：<strong>·代码内容·</strong> (单引号，键盘Esc键下面那个，这里显示的是一个点)</li><li>代码块：连用三个 <strong>·</strong> (代码块中会使用语法高亮显示)</li></ul><p>【注】在使用代码块时，在三个单引号后面输入指定的语言，来选择语法高亮显示的方式。Ob支持的语言和相应代号可以在这里找到： <a href="https://link.zhihu.com/?target=https://prismjs.com/%23supported-languages">supported-languages</a> 。<br>‘<ul class="box"></p><p>            <li>1</li><br>            <ol>2</ol></p><p>            <li>2</li></p><p>            <li>3</li></p><p>            <li class="last">4</li></p><p>        </ul>‘        </p><h3 id="7-文字样式"><a href="#7-文字样式" class="headerlink" title="7. 文字样式"></a>7. 文字样式</h3><p>斜体：<em><strong>内容</strong></em> 快捷键 Ctrl+I<br>粗体：<strong><strong>内容</strong></strong> 快捷键Ctrl+B<br>斜+粗：<em><strong><strong>内容</strong></strong></em><br>删除线：**<del>内容</del>**<br>高亮文本：**&#x3D;&#x3D;内容&#x3D;&#x3D;**</p><p><strong>【注】</strong>在这里 ***** 与 <strong>_</strong> 是通用的</p><h3 id="8-插入图片与音频"><a href="#8-插入图片与音频" class="headerlink" title="8. 插入图片与音频"></a>8. 插入图片与音频</h3><ul><li>网络附件：**<img src="/%E5%9B%BE%E7%89%87" alt="附件描述">**</li><li>本地附件：**![[带后缀文件名]]** 或者直接从本地拖入</li></ul><p>【注1】在Ob中拖入的本地图片与音频会以附件的重新复制到库中，建议先在库中新建一个文件夹，然后右键选择将其作为附件文件夹，这样所有新添加的附件就都会保存到该文件夹中，方便管理。</p><p>【注2】直接使用**![[带后缀文件名]]**语句时，附件需已存放在附件文件夹中。</p><h3 id="9-标签"><a href="#9-标签" class="headerlink" title="9. 标签"></a><strong>9. 标签</strong></h3><p>首先在插件中打开标签管理插件，<br>然后在笔记中使用 <strong>#</strong>+<strong>标签文本</strong> 添加标签。</p><h3 id="10-任务列表-复选框"><a href="#10-任务列表-复选框" class="headerlink" title="10. 任务列表 复选框"></a>10. 任务列表 复选框</h3><ul><li>已完成：**- [x]**+<strong>空格</strong>+<strong>内容</strong></li><li>未完成：**- [ ]**+<strong>空格</strong>+<strong>内容</strong></li><li><input disabled="" type="checkbox"> ⏫ 天天签到</li></ul><p>【注】在预览界面中可以直接单击复选框来改变其状态。</p><h3 id="11-绘制表格"><a href="#11-绘制表格" class="headerlink" title="11. 绘制表格"></a>11. 绘制表格</h3><p><img src="https://pic4.zhimg.com/v2-ed3f84501832dc56d7d63180366c9d8f_b.jpg"></p><ul><li>用符号 | 作为列分割。| 和其他字符之间要加空格。</li><li>表头和表体使用 <strong>—-</strong> 进行分割，其中 <strong>-</strong> 的数量应≥3。</li><li>在分割栏横线中使用 <strong>:</strong> 设置该列文本对齐方式，不加为居左，头尾加为居中，尾加为右。</li><li>单元格内换行可用**<br/>**。</li><li>每一行的列数允许少于总列数。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#### 这是一个简单的3x3表格示例：</span><br><span class="line"></span><br><span class="line">| 标题0 | 标题1 | 标题2 |</span><br><span class="line">|----|----|----|</span><br><span class="line">| ddd | sss | aaa |</span><br><span class="line">| ccc | xxx | zzz |</span><br><span class="line"></span><br><span class="line">（复制过去之后记得按照这个格式排版）</span><br></pre></td></tr></table></figure><h3 id="12-脚注"><a href="#12-脚注" class="headerlink" title="12. 脚注"></a>12. 脚注</h3><ul><li>普通脚注：**[^脚注简介]** 然后另起一行输入 <strong>[^脚注简介]: 脚注内容</strong></li><li>内部脚注：<strong>^[脚注内容]</strong></li></ul><p><img src="https://pic3.zhimg.com/v2-a5523967dfbaddd56041f9d610dd05de_b.jpg"></p><h3 id="13-数学公式"><a href="#13-数学公式" class="headerlink" title="13. 数学公式"></a>13. 数学公式</h3><h3 id="14-内部链接"><a href="#14-内部链接" class="headerlink" title="14. 内部链接"></a><strong>14. 内部链接</strong></h3><p>链接到其它页面(笔记)： <strong>[[笔记名称]]</strong><br>直接在笔记中嵌入其它笔记内容：**! [[笔记名称]]**</p><p>【注】当在笔记中直接输入**[[名称]]**创建一个内部链接时，若该链接指定的页面不存在，则关系图中会使用一个灰色的节点来表示。单击该节点或者在预览中单击链接，将会直接创建一个新笔记。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实用类小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/30/Test/hello-world/"/>
      <url>/2022/11/30/Test/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! </p><span id="more"></span><p>This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
